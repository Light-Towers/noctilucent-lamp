 # 排序算法
> Hello 算法：https://www.hello-algo.com/chapter_sorting/sorting_algorithm/

**1.插入类**

* 插入排序（Insertion Sort）：通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。
* 希尔排序（Shell Sort）：是插入排序的一种更高效的改进版本，也称为缩小增量排序，通过将原始列表分割成多个子列表分别进行插入排序来实现。

**2.选择类**

* [简单]选择排序（Selection Sort）：在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。
* 堆排序（Heap Sort）：利用堆这种数据结构设计的一种排序算法，可以看作是选择排序的优化版。

**3.交换类**

* 冒泡排序（Bubble Sort）：通过重复遍历要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。

* 快速排序（Quick Sort）：同样是一种分而治之的策略，它选择一个“基准”元素，将数组分为两部分，左边都比基准小，右边都比基准大，递归地排序两个子数组。

  **基准元素选择**

   1. **固定位置选择**
  - **选择最后一个元素**：这是最常见的方法，也是最简单的实现方式。
  - **选择第一个元素**：同样简单，但可能会导致性能问题，特别是在数组已经部分有序的情况下。

  2. **随机选择**：
  - **随机选择一个元素**：通过随机选择基准元素可以减少最坏情况发生的概率，提高算法的平均性能。

  3. **中位数选择**
  - **选择“三数取中”**：选择数组的第一个、中间和最后一个元素中的中位数作为基准元素。这种方法可以进一步减少最坏情况的发生概率，适用于部分有序的数组。

  4.  **多数选择**
  - **选择多个元素的中位数**：在较大的数组中，可以选择多个元素的中位数作为基准元素，以进一步优化性能，但实现复杂度较高。

**4.其它**

* 归并排序（Merge Sort）：采用分治法的一个非常典型的应用，将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。

* 计数排序（Counting Sort）：适用于一定范围内的整数排序，通过计算每个值出现的次数作为索引存储到额外的数组中。
* 桶排序（Bucket Sort）：将数组分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是递归使用桶排序）。
* 基数排序（Radix Sort）：根据键值的每位数字来分配桶，从最低有效位开始排序，然后再收集起来，直到最高有效位。

# 指标对比
| 排序算法 | 最小时间复杂度 | 最大时间复杂度 | 平均时间复杂度 | 平均空间复杂度 | 稳定性(相等元素的相对位置不会发生变化) |
| --------| -------------- | -------------- | -------------- | ---------- | ------ |
| 插入排序 | O(n) `基本有序最优` | O(n^2^)        | O(n^2^)        | O(1)      | 稳定   |
| 希尔排序 | O(n)           | O(n^2^)        | O(n^(3/2))     | O(1)      | 不稳定 |
| 选择排序 | O(n^2^)        | O(n^2^)        | O(n^2^)        | O(1)       | 不稳定 |
| 堆排序   | O(n log n)     | O(n log n)     | O(n log n)     | O(1)      | 不稳定 |
| 归并排序 | O(n log n)     | O(n log n)     | O(n log n)     | O(n)      | 稳定   |
| 冒泡排序 | O(n)`基本有序最优`   | O(n^2^)        | O(n^2^)        | O(1)       | 稳定   |
| 快速排序 | O(n log n)     | O(n^2^) `基本有序最差`<br />优化措施（如随机选择枢轴、三数取中等） | O(n log n)     | O(log n)   | 不稳定 |
| 计数排序 | O(n + k)       | O(n + k)       | O(n + k)       | O(k)       | 稳定   |
| 桶排序   | O(n + k)       | O(n^2^)        | O(n + k)       | O(n + k)  | 稳定   |
| 基数排序 | O(nk)          | O(nk)          | O(nk)          | O(n + k)   | 稳定   |

其他对比指标
适应性：某些算法在输入数据部分有序时表现更好，如插入排序和冒泡排序。
原地排序：是否需要额外的存储空间。大多数原地排序算法的空间复杂度为 O(1)。
在线排序：是否可以在接收数据的同时进行排序，如插入排序。
多线程支持：某些算法可以很容易地并行化，如归并排序和快速排序。

