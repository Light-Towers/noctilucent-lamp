 # 排序算法
> Hello 算法：https://www.hello-algo.com/chapter_sorting/sorting_algorithm/

[简单]选择排序（Selection Sort）：在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。
插入排序（Insertion Sort）：通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。
希尔排序（Shell Sort）：是插入排序的一种更高效的改进版本，也称为缩小增量排序，通过将原始列表分割成多个子列表分别进行插入排序来实现。
冒泡排序（Bubble Sort）：通过重复遍历要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。
归并排序（Merge Sort）：采用分治法的一个非常典型的应用，将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。
快速排序（Quick Sort）：同样是一种分而治之的策略，它选择一个“基准”元素，将数组分为两部分，左边都比基准小，右边都比基准大，递归地排序两个子数组。
堆排序（Heap Sort）：利用堆这种数据结构设计的一种排序算法，可以看作是选择排序的优化版。
计数排序（Counting Sort）：适用于一定范围内的整数排序，通过计算每个值出现的次数作为索引存储到额外的数组中。
桶排序（Bucket Sort）：将数组分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是递归使用桶排序）。
基数排序（Radix Sort）：根据键值的每位数字来分配桶，从最低有效位开始排序，然后再收集起来，直到最高有效位。

# 指标对比
| 排序算法 | 最小时间复杂度 | 最大时间复杂度 | 平均时间复杂度 | 空间复杂度 | 稳定性(相等元素的相对位置不会发生变化) |
| --------| -------------- | -------------- | -------------- | ---------- | ------ |
| 冒泡排序 | O(n)           | O(n^2^)        | O(n^2^)        | O(1)       | 稳定   |
| 选择排序 | O(n^2^)        | O(n^2^)        | O(n^2^)        | 0(1)       | 不稳定 |
| 插入排序 | O(n)           | O(n^2^)        | O(n^2^)        | 0(1)       | 稳定   |
| 希尔排序 | O(n)           | O(n^2^)        | O(n^(3/2))     | 0(1)       | 不稳定 |
| 归并排序 | O(n log n)     | O(n log n)     | O(n log n)     | 0(n)       | 稳定   |
| 快速排序 | O(n log n)     | O(n^2^)        | O(n log n)     | O(log n)   | 不稳定 |
| 堆排序   | O(n log n)     | O(n log n)     | O(n log n)     | 0(1)       | 不稳定 |
| 计数排序 | O(n + k)       | O(n + k)       | O(n + k)       | O(k)       | 稳定   |
| 桶排序   | O(n + k)       | O(n^2^)        | O(n + k)       | 0(n + k)   | 稳定   |
| 基数排序 | O(nk)          | O(nk)          | O(nk)          | O(n + k)   | 稳定   |

其他对比指标
适应性：某些算法在输入数据部分有序时表现更好，如插入排序和冒泡排序。
原地排序：是否需要额外的存储空间。大多数原地排序算法的空间复杂度为 O(1)。
在线排序：是否可以在接收数据的同时进行排序，如插入排序。
多线程支持：某些算法可以很容易地并行化，如归并排序和快速排序。

