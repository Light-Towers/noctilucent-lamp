# 软件工程基础/系统开发基础

---
# 软件开发模型

## 1. 增量模型（Incremental Model）
- **定义**：瀑布模型的变体，具有其优点。
- **优点**：
  - 初始版本成本和时间少；
  - 风险较小；
  - 快速交付减少需求变更；
  - 可逐步投资。
- **缺点**：
  - 初始增量可能不稳定；
  - 需求变动可能导致重新开发；
  - 管理复杂度高。

## 2. V模型
- **特点**：强调测试与开发阶段的对应关系。
- **对应关系**：
  - **系统测试 & 验收测试** → 针对需求分析；
  - **集成测试** → 针对概要设计；
  - **单元测试** → 针对详细设计；
  - **编码实现** → 软件具体实现。

- **V模型图示**：
<img src="https://raw.githubusercontent.com/Light-Towers/picture/master/noctilucent-lamp/软件模型-V模型图示.png" alt="软件模型-V模型图示.png" style="zoom: 67%;" />



## 测试与开发阶段对应关系
- **系统测试 & 验收测试**：对应于需求分析阶段。
- **集成测试**：对应于概要设计阶段。
- **单元测试**：对应于详细设计阶段。
- **软件实现**：对应于编码阶段。

## 系统设计

### 概要设计
主要任务：
1. 设计软件系统的总体结构：
   - 将复杂系统按功能划分成模块；
   - 确定每个模块的功能；
   - 确定模块之间的调用关系；
   - 确定模块间的接口（即模块之间传递的信息）；
   - 评价模块结构的质量。
2. 数据结构及数据库设计：
   - 对需求分析阶段描述的数据组成、操作约束和数据间的关系进行细化；
   - 在详细设计阶段进一步具体化。

文档输出：
- 概要设计说明书；
- 数据库设计说明书；
- 用户手册；
- 修订后的测试计划。

评审内容：
- 是否完整实现了需求中的功能和性能要求；
- 设计的可行性；
- 关键处理逻辑及外部接口定义的正确性、有效性；
- 各部分设计的一致性等。

### 详细设计
主要任务：
- 对每个模块进行详细的算法设计，使用图形、表格或语言工具描述每个模块的处理过程。
- 对模块内的数据结构进行设计。
- 对数据库进行物理设计（确定数据库的物理结构）。
- 其他设计（根据系统类型可能包括代码设计、输入/输出格式设计、用户界面设计等）。
- 编写详细设计说明书。

评审内容：
- 处理过程的算法；
- 数据库的物理结构。

## 软件设计阶段产物总结
| 开发阶段       | 主要产物                                               |
|----------------|--------------------------------------------------------|
| 需求分析       | 数据流图、数据字典                                     |
| 概念设计       | ER模型                                                 |
| 逻辑设计       | 关系模式、规范化理论                                   |
| 物理设计       | 物理特性                                               |

## 结构化开发方法
* 核心思想：自顶向下、逐步分解求精、阶段、阶分明、标准化。
* 产出物：
  - 分层的数据流图；
  - 数据词典；
  - 加工逻辑说明；
  - 补充材料。

---
# 人机界面设计 —— 黄金三原则
## 1. **用户操纵控制**
- 以不强迫用户进入不必要或不希望的动作的方式来定义交互模式；
- 提供灵活的交互方式；
- 允许中断和撤销用户操作；
- 当用户的技能水平提升时，可以使交互更加流线化，并允许定制化交互；
- 设计应使用户与内部技术细节隔离，直接与屏幕上出现的对象交互。

## 2. **减轻用户的记忆负担**
- 减少对用户短期记忆的需求；
- 建立有意义的默认值；
- 定义直观的快捷方式；
- 界面视觉布局基于现实世界的象征（易于联想）；
- 以逐步进展的方式揭示信息，避免信息过载。

## 3. **保持界面的一致性**
- 允许用户将当前任务置于有意义的上下文中；
- 在应用系统家族中保持一致的交互风格；
- 如果已建立用户熟悉的交互模型，除非有不可抗力，否则不应随意更改。  

---
# 软件质量保证 (ISO/IEC 9126)
![软件质量保证](https://raw.githubusercontent.com/Light-Towers/picture/master/noctilucent-lamp/软件质量保证.png)

## 主要质量特性及子特性
| 质量特性     | 子特性                                                                 |
|--------------|------------------------------------------------------------------------|
| **功能性**   | 适合性、准确性、互用性、依从性、**安全性**                                 |
| **可靠性**   | **成熟性**、容错性、易恢复性                                               |
| **易使用性** | 易理解性、易学性、易操作性                                             |
| **效率**     | 时间特性、资源特性                                                     |
| **可维护性** | 易分析性、易改变性、稳定性、易测试性                                   |
| **可移植性** | 适应性、易安装性、一致性、易替换性                                     |

## 可维护性质量特性详解

### 定义：
可维护性是指与软件维护的难易程度相关的一组软件属性。

### 四个关键子特性：
1. **易分析性**
   - 描述：诊断缺陷或失效原因、判定待修改程度的难易程度。
   
2. **稳定性**
   - 描述：修改造成难以预料的后果的风险程度。
   - 特点：风险程度越低，稳定性越好。

3. **易测试性**
   - 描述：测试已修改软件的难易程度。

4. **易改变性**
   - 描述：修改、排错或适应环境变化的难易程度。

---
# 软件评审
正式的技术评审FTR(FormalTechnical Review)是软件工程师组织的软件质量保证活动，包含以下指导原则：
* 软件评审是评审软件产品，不要涉及对软件生产者能力的评价;
* 评审前要制定严格的评审计划，并严格遵守预计的日程安排;
* 对评审中出现的问题要记录在案，不要过多地讨论解决方案，把问题留给软件生产者来解决;
* 要限制参与者人数，并要求参加评审的人员在评审会之前仔细阅读文档，做好充分的准备。

---
# 软件设计原则

软件设计中遵循“**高内聚、低耦合**”是提高系统可维护性、可扩展性和可理解性的关键原则。

## 一、模块内聚性（Cohesion）

描述：模块内部各组成成分之间的联系紧密程度，从低到高可分为以下几种类型：

| 内聚类型     | 描述                                                                 |
|--------------|----------------------------------------------------------------------|
| **偶然聚合** | 模块完成的动作之间没有任何关系，或者仅仅是非常松散的关系。               |
| **逻辑聚合** | 模块内部的各个组成在**逻辑**上具有相似的处理动作，但**功能用途**上彼此**无关**。 |
| **时间聚合** | 模块内部的各个组成部分所包含的处理动作必须在**同一时间**内执行。             |
| **过程聚合** | 模块内部各个组成部分所要完成的动作虽然没有关系，但必须按**特定的次序**执行。   |
| **通信聚合** | 模块的各个组成部分所完成的动作都使用了**同一个数据**或产生**同一输出数据**。   |
| **顺序聚合** | 模块内部的各个部分，**前一部分**处理动作的**最后输出**是**后一部分**处理动作的**输入**。 |
| **功能聚合** | 模块内部各个部分全部属于一个整体，并执行同一功能，且各部分对实现该功能都必不可少。 |

> ✅ **理想状态为功能聚合**，这是最理想的模块划分方式。

## 二、模块耦合性（Coupling）

描述：模块之间依赖关系的强弱程度，从低到高可分为以下几种类型：

| 耦合类型         | 描述                                                                                     |
|------------------|------------------------------------------------------------------------------------------|
| **非直接耦合**   | 两个模块之间没有直接关系，它们之间的联系完全是通过**主模块**的控制和调用来实现的。              |
| **数据耦合**     | 一组模块借助参数表传递**简单数据项**。                                                           |
| **标记耦合**     | 一组模块通过参数表传递**记录信息（数据结构**）。                                                 |
| **控制耦合**     | 模块之间传递的信息中包含用于**控制**模块内部逻辑的信息。                                           |
| **外部耦合**     | 一组模块都访问同一**全局简单变量**，而且不是通过参数表传递该全局变量的信息。                        |
| **公共耦合**     | 多个模块都访问同一个**公共数据环境**（如全局变量、共享数据库等），耦合度较高。                      |
| **内容耦合**     | 最高耦合级别，存在以下任一情况：<br>1. 一个模块直接访问另一个模块的内部数据；<br>2. 一个模块不通过正常入口转到另一个模块的内部；<br>3. 两个模块有一部分程序代码重叠；<br>4. 一个模块有多个入口。 |

> ❌ **内容耦合是最差的设计**，应尽量避免；推荐使用**数据耦合**或更低级别的耦合。

## 三、设计建议

- **追求高内聚**：每个模块应专注于单一职责，尽可能达到**功能聚合**。
- **降低耦合度**：模块间交互应简洁明确，优先选择**数据耦合**，避免**控制耦合**和**内容耦合**。
- **良好的模块化设计**可以提升系统的可维护性、可测试性和可扩展性。

## 四、总结对比

| 维度       | 理想状态        | 不良状态      |
|------------|----------------|---------------|
| 内聚性     | 功能聚合       | 偶然聚合      |
| 耦合性     | 数据耦合       | 内容耦合      |

> 📌 **设计目标**：构建**高内聚、低耦合**的模块结构，以支持系统的长期发展与稳定运行。

---
# 系统测试
## 系统测试方法

### 1.黒盒测试

黒盒测试:等价类划分、边界值分析、错误推测、因果图。
常考的黑盒测试方法:
等价类划分:确定无效与有效等价类，设计用例尽可能多的覆盖有效类，设计用例只覆盖一个无效类。
边界值分析:处理边界情况时最容易出错，选取的测试数据应该恰好等于、稍小于或稍大于边界值。

### 2.白盒测试

白盒测试:语句覆盖、判定覆盖、条件覆盖、条件/判定覆盖、路径覆盖。

|                     | 定义                                                         | 特点                                                         |
| ------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 语句覆盖            | 被测试程序中的每条语句至少执行一次。                         | 对执行逻辑覆盖很低,一般认为是很**弱**的逻辑覆盖。            |
| 判定覆盖 (分支覆盖) | 被测程序每个判定表达式至少获得一次"真"值 和"假"值(或者程序中每一个判定取"真"分 支和取"假"分支至少通过一次。) | 判定覆盖比语句覆盖更强一些。判定 可以是1个条件,也可以是多个条件的组合。 |
| 条件覆盖            | 每一个判定语句中**每个逻辑**条件的各种可能的值至少满足一次。 | 条件覆盖和判断覆盖没有包含关系。                             |
| 判断/条件覆盖       | 判定中每个条件的所有可能取值(真/假)至少 出现一次,并使每个判定本身的判定结果(真/ 假)也至少出现一次。 | 同时满足判定覆盖和条件覆盖。                                 |
| 条件组合覆盖        | 每个判定中的各种可能值的组合都至少出现一 次。                | 同时满足判定覆盖、条件覆盖、判定/ 条件覆盖。                 |
| 路径覆盖            | 覆盖被测试程序中所有可能的路径。                             | 可以对程序进行彻底的测试,比语句 覆盖、条件覆盖、判定覆盖、条件判 定覆盖及条件组合覆盖的覆盖面都 广。 |

### 3.阶段测试

* 验收测试:有效性测试、软件配置审查、验收测试。
* 系统测试:恢复测试、安全性测试、强度测试、性能测试、可靠性测试和安装测试。
* 集成测试:模块间的接口和通信。
单元测试:**模块**接口、**局部**数据结构、边界条件、独立的路径、错误处理。
* 其他测试:回归测试(修改软件后进行的测试，防止引入新的错误)。负载测试(对软件负载能力的测试)。压力测试(对软件超负荷条件下运行情况的测试)。

## 环路复杂度 
环路复杂度公式：V(G)=E-N+2, 其中E为边的数量，N为节点的数量

---
#  数据流图
#### **1. 数据流图（DFD）的核心要素**
- **外部实体（External Entity）**：系统外的数据来源或去向（如用户、其他系统）。  
- **数据流（Data Flow）**：数据在系统内的流动方向（箭头表示）。  
- **加工/处理（Process）**：对数据的变换或操作（圆角矩形表示）。  
- **数据存储（Data Store）**：数据的临时或永久存储（开口矩形表示）。

#### **2. 分层DFD的绘制原则**
- **父图与子图平衡**：子图的输入/输出数据流必须与父图的对应加工一致。  
- **数据守恒**：每个加工必须有输入和输出数据流，避免“黑洞”或“奇迹”。  
- **分解均匀**：每层分解后，各部分复杂度应接近，避免单一分解过细或过粗。  
- **避免控制逻辑**：DFD仅关注数据流动，不涉及具体控制流程（如条件分支、循环）。

#### **3. 常见错误**
- **遗漏数据流**：未标识所有必要的数据输入/输出。  
- **过度连接**：单个加工关联过多数据流，导致逻辑混乱。  
- **混淆控制与数据**：错误地将控制信号（如“开始”“结束”）作为数据流。  
- **命名不规范**：使用模糊名称（如“处理数据”），未明确功能。

---
# 软件可靠性
## 关键定义
   - **MTTF（Mean Time To Failure）**：平均无故障时间，系统正常运行到发生故障的平均时间
   - **MTTR（Mean Time To Repair）**：平均故障修复时间，修复故障所需的平均时间。  
   - **可维护性**：衡量系统在发生故障后，能否在规定时间内通过维护恢复功能的能力  

## 核心指标
   - 可维护性与 MTTR（平均故障修复时间）直接相关
   - MTTR 越小，可维护性越高
   - MTTF 越大，系统越可靠
   - 当 MTTR 远小于 MTTF 时，MTBF ≈ MTTF

## 实际应用
   - **MTTR优化**：缩短故障修复时间是提高可维护性的关键
   - 在计算可用性时，一般认为 MTTR 很小
   - **MTBF近似**：对于 MTBF（平均故障间隔时间），其完整公式为 MTBF = MTTF + MTTR

## 指标对比
|   指标   |           公式            |                 说明                  |
| :------: | :-----------------------: | :-----------------------------------: |
| 可维护性 |  $ \frac{1}{1 + MTTR} $   | MTTR越小，分母越接近1，可维护性越高。 |
|  可靠性  | $ \frac{MTTF}{1 + MTTF} $ |        MTTF越大，系统越可靠。         |
|  可用性  | $ \frac{MTBF}{1 + MTBF} $ | 一般MTTR很小，其中 MTBF ≈ MTTF + MTTR |

---
# 模块设计原则

## 核心概念

### 作用范围（影响范围）
- 定义：受该模块内部一个判定影响的所有模块集合
- 只有某一模块内含有依赖于该判定的操作，那么该模块就在该判定的作用范围内

### 控制范围
- 定义：模块本身以及其所有下属模块（直接或间接从属于它的模块）的集合
- 控制范围完全取决于系统的结构，与模块本身的功能没有直接关系

## 设计规则

1. **作用范围与控制范围的关系**
   - 任何一个判断的作用范围应该是这个判断所在模块的控制范围的一个子集
   - 所有受判断影响的模块应该从属于做出判断的那个模块

2. **层次靠近原则**
   - 受模块M判定影响的模块，最好局限于模块M本身或其直接下属模块
   - 判定所在的模块应在其影响的模块在层次上尽量靠近

## 改进方法
当发现模块作用范围不在其控制范围之内时，可以采用以下方法改进：
1. **上移判点**：将判定上移到更高层的模块
2. **下移受影响模块**：将受判断影响的模块下移到判断所在模块的控制范围内

## 设计目标
- 理想的设计是使一个模块的作用范围在其控制范围之内
- 这样的设计可以保证系统的清晰性和可维护性，避免跨层级的复杂依赖关系

---
# 统一开发过程（RUP）
Rational Unified Process（RUP）是由Rational Software公司开发的一种迭代式软件开发框架，后随公司被IBM收购。它结合了结构化方法和迭代开发的优点，广泛用于复杂项目。

### **核心特点**
1. **迭代与增量开发**
   将项目分解为多个迭代，每个迭代交付可运行版本，逐步完善功能，降低风险。

2. **用例驱动**
   以用户需求（用例）为核心，确保开发始终围绕实际需求展开。

3. **以架构为中心**
   早期确立系统架构，作为设计和决策的基础，保障系统扩展性和稳定性。

4. **风险驱动**
   优先解决高风险问题，通过早期迭代验证关键技术方案。

### **四个阶段**
1. **初始阶段（Inception）**  
   - **目标**：明确项目范围、可行性和商业案例。
   - **里程碑**：生命周期目标
   - **产出**：构想文档、用例模型调查报告、初始业务用例、早期风险评估、阶段与迭代的项目计划。

2. **细化阶段（Elaboration）**  
   - **目标**：建立稳定的系统架构，细化需求与计划。
   - **里程碑**：生命周期架构
   - **产出**：补充需求分析、软件架构描述、可执行的架构原型

3. **构建阶段（Construction）**  
   - **目标**：开发可交付的软件增量，完成主体编码。
   - **里程碑**：最初运作能力
   - **产出**：具备最初运作能力的集成软件产品、用户手册、当前版本的详细描述

4. **移交阶段（Transition）**  
   - **目标**：产品部署、用户培训与反馈整合。
   - **里程碑**：产品发布
   - **产出**：产品发布版本

### **六大最佳实践**
1. **迭代开发**：分阶段验证功能，降低风险。  
2. **需求管理**：通过用例明确需求，减少变更影响。  
3. **组件化架构**：提升复用性，简化维护。  
4. **可视化建模**：使用UML图辅助设计与沟通。  
5. **持续质量验证**：每个迭代均进行测试。  
6. **变更控制**：严格管理需求与设计变更。
