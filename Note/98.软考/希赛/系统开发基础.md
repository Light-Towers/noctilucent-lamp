# 软件工程基础/系统开发基础

环路复杂度公式：V(G)=E-N+2, 其中E为边的数量，N为节点的数量


 RUP（Rational Unified Process）分为4个阶段，每个阶段结束时都有重要的里程碑：
 1. 初启阶段结束时的里程碑是生命周期目标；
 2. 精化阶段结束时的里程碑是生命周期架构；
 3. 构建阶段结束时的里程碑是最初运作能力；
 4. 移交阶段的里程碑是产品发布。



# 软件开发模型

## V模型图示：

<img src="https://raw.githubusercontent.com/Light-Towers/picture/master/noctilucent-lamp/软件模型-V模型图示.png" alt="软件模型-V模型图示.png" style="zoom: 67%;" />

![软件模型-V模型图示_2](https://raw.githubusercontent.com/Light-Towers/picture/master/noctilucent-lamp/软件模型-V模型图示_2.png)

**系统测试和验收测试**针对于**需求分析**；

**集成测试**针对于**概要设计**；

**单元测试针**对于**详细设计**；

**软件实现**应该是针对于**编码**部分；



### 系统设计

#### 概要设计
* 设计软件系统总体结构:基本任务还是采用某种设计方法，将一个复杂的系统按功能划分成模块;确定每个模块的功能;确定模块之间的调用关系;确定模块之间的接口，即模块之间传递的信息;评价模块结构的质量。
* 数据结构及数据库设计:在需求分析阶段对数据的组成、操作约束和数据之间的关系进行了描述，概要设计阶段要加以细化，详细设计阶段则规定具体的实现细节。
* 编写概要设计文档:概要设计说明书、数据库设计说明书、用户手册以及修订测试计划。
* 评审:对设计部分是否完整地实现了需求中规定的功能、性能等要求，设计的可行性，关键的处理以及外部接口定义的正确性、有效性、各部分之间的一致性等都--进行评审。

#### 详细设计
对每个模块进行详细的算法设计，用某种图形、表格和语言等工具将每个模块处理过程的详细算法描述出来。
对模块内的数据结构进行设计。
对数据库进行物理设计，即确定数据库的物理结构。
其他设计:根据软件系统的类型，还可能需要进行代码设计、输入/输出格式设计，用户界面设计等。编写详细设计说明书。
评审:对处理过程的算法和数据库的物理结构都要评审。


软件详细设计阶段的主要任务包括:对模块内的数据结构进行设计;对数据库进行物理设计;对每个模块进行详细的算法设计;代码设计、输入/输出设计、用户界面设计等其他设计。

软件概要设计阶段的主要任务包括:
(1)软件系统总体结构设计，将系统划分成模块;确定每个模块的功能;确定模块之间的调用关系;确定模块之间的接口，即模块之间传递的信息;评价模块结构的质量。
(2)数据结构及数据库设计。




# 需求分析
结构化方法的分析结果由以下几部分组成:一套分层的数据流图、一本数据词典、一组小说明(也称加工逻辑说明)、补充材料。


# 人机界面设计
人机交互“黄金三原则”包括:用户操纵控制、减轻用户的记忆负担、保持界面的一致性。
**用户操纵控制**:以不强迫用户进入不必要或不希望的动作的方式来走义交互模式;提供灵活的交互;允许中断和撤销用户交互;当技能级别增长时可以使交互流线化并允许定制交互;使用户与内部技术细节隔离开来;设计应允许用户与出现在屏幕上的对象直接交互。
**减轻用户的记忆负担**:减少对短期记忆的要求;建立有意义的默认;定义直观的快捷方式;界面的视觉布局应该基于真实世界的象征;以不断进展的方式揭示信息。
**保持界面的一致性**:允许用户将当前任务放入有意义的环境中;在应用系统家族中保持一致;如果过去的交互模型已经建立起了用户期望，除非有不得已的理由，否则不要改变它。



# 软件质量保证
![软件质量保证](https://raw.githubusercontent.com/Light-Towers/picture/master/noctilucent-lamp/软件质量保证.png)

功能性:适合性、准确性、互操作性、**安全保密性**。
可靠性:**成熟性**、容错性、易恢复性。
易用性:易理解性、易学性、易操作性、吸引性。
效率:时间特性、资源利用性。
维护性:**易分析性、稳定性、易测试性、易改变性。**
可移植性:适应性、易安装性、**共存性**、易替换性。

ISO/EC 9126软件质量模型，该模型的质量特性和质量子特性如下
功能性(适合性、准确性、互用性、依从性、安全性)
可靠性(成熟性、容错性、易恢复性)
易使用性(易理解性、易学性、易操作性)
效率(时间特性、资源特性);
可维护性(易分析性、易改变性、稳定性、易测试性)
可移植性(适应性、易安装性、一致性、易替换性)




# 软件设计原则

高内聚、低耦合

## 内聚性

偶然聚合:模块完成的动作之间没有任何关系，或者仅仅是一种非常松散的关系。
逻辑聚合:模块内部的各个组成在**逻辑**上具有相似的处理动作，但**功能用途**上彼此**无关**。
时间聚合:模块内部的各个组成部分所包含的处理动作必须在**同一时间**内执行。
过程聚合:模块内部各个组成部分所要完成的动作虽然没有关系，但必须按**特定的次序**执行。
通信聚合:模块的各个组成部分所完成的动作都使用了**同一个数据**或产生**同一输出数据**。
顺序聚合:模块内部的各个部分，**前一部分**处理动作的**最后输出**是**后一部分**处理动作的**输入**。
功能聚合:模块内部各个部分全部属于一个整体，并执行同一功能，且各部分对实现该功能都必不可少

## 耦合性

非直接耦合: 两个模块之间没有直接关系,它们之间的联系完全是通过**主模块**的控制和调用来实现的
数据耦合: 一组模块借助参数表传递**简单数据**
标记耦合: 一组模块通过参数表传递记录信息(**数据结构**)
控制耦合: 模块之间传递的信息中包含用于**控制**模块内部逻辑的信息
外部耦合: 一组模块都访问同一**全局简单变量**,而且不是通过参数表传递该全局变量的信息
公共耦合: 多个模块都访问同一个**公共数据环境**
内容耦合: 1. 一个模块直接访问另一个模块的内部数据; 2. 一个模块不通过正常入口转到另一个模块的内部; 3. 两个模块有一部分程序代码重叠; 4.一个模块有多个入口 



# 系统测试

## 黒盒测试

黒盒测试:等价类划分、边界值分析、错误推测、因果图。
常考的黑盒测试方法:
等价类划分:确定无效与有效等价类，设计用例尽可能多的覆盖有效类，设计用例只覆盖一个无效类。
边界值分析:处理边界情况时最容易出错，选取的测试数据应该恰好等于、稍小于或稍大于边界值。

## 白盒测试

白盒测试:语句覆盖、判定覆盖、条件覆盖、条件/判定覆盖、路径覆盖。

|                     | 定义                                                         | 特点                                                         |
| ------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 语句覆盖            | 被测试程序中的每条语句至少执行一次。                         | 对执行逻辑覆盖很低,一般认为是很**弱**的逻辑覆盖。            |
| 判定覆盖 (分支覆盖) | 被测程序每个判定表达式至少获得一次"真"值 和"假"值(或者程序中每一个判定取"真"分 支和取"假"分支至少通过一次。) | 判定覆盖比语句覆盖更强一些。判定 可以是1个条件,也可以是多个条件的组合。 |
| 条件覆盖            | 每一个判定语句中**每个逻辑**条件的各种可能的值至少满足一次。 | 条件覆盖和判断覆盖没有包含关系。                             |
| 判断/条件覆盖       | 判定中每个条件的所有可能取值(真/假)至少 出现一次,并使每个判定本身的判定结果(真/ 假)也至少出现一次。 | 同时满足判定覆盖和条件覆盖。                                 |
| 条件组合覆盖        | 每个判定中的各种可能值的组合都至少出现一 次。                | 同时满足判定覆盖、条件覆盖、判定/ 条件覆盖。                 |
| 路径覆盖            | 覆盖被测试程序中所有可能的路径。                             | 可以对程序进行彻底的测试,比语句 覆盖、条件覆盖、判定覆盖、条件判 定覆盖及条件组合覆盖的覆盖面都 广。 |

## 阶段测试

* 验收测试:有效性测试、软件配置审查、验收测试。
* 系统测试:恢复测试、安全性测试、强度测试、性能测试、可靠性测试和安装测试。
* 集成测试:模块间的接口和通信。
单元测试:**模块**接口、**局部**数据结构、边界条件、独立的路径、错误处理。
* 其他测试:回归测试(修改软件后进行的测试，防止引入新的错误)。负载测试(对软件负载能力的测试)。压力测试(对软件超负荷条件下运行情况的测试)。







**软件工程开发方法**：自顶向下、逐步分解求精、严格区分阶段、阶段产生标准化。



## 不同阶段的产物
需求分析:数据流图、数据字典
概念设计:ER模型
逻辑设计:关系模式、规范法理论
物理设计:物理特性等



# 增量模型
增量模型作为瀑布模型的一个变体，具有瀑布模型的所有优点。

* 优点:
第一个可交付版本所需要的成本和时间很少;
开发由增量表示的小系统所承担的风险不大;
由于很快发布了第一个版本，因此可以减少用户需求的变更:运行增量投资，即在项目开始时，可以仅对一个或两个增量进行投资。

* 缺点:
如果没有对用户变更的要求进行规划，那么产生的初始量可能会造成后来增量的不稳定;
如果需求不像早期思考的那样稳定和完整，那么一些增量就可能需要重新开发，重新发布;
管理发生的成本进度和配置的复杂性可能会超出组织的能力。



#  数据流图
#### **1. 数据流图（DFD）的核心要素**
- **外部实体（External Entity）**：系统外的数据来源或去向（如用户、其他系统）。  
- **数据流（Data Flow）**：数据在系统内的流动方向（箭头表示）。  
- **加工/处理（Process）**：对数据的变换或操作（圆角矩形表示）。  
- **数据存储（Data Store）**：数据的临时或永久存储（开口矩形表示）。

#### **2. 分层DFD的绘制原则**
- **父图与子图平衡**：子图的输入/输出数据流必须与父图的对应加工一致。  
- **数据守恒**：每个加工必须有输入和输出数据流，避免“黑洞”或“奇迹”。  
- **分解均匀**：每层分解后，各部分复杂度应接近，避免单一分解过细或过粗。  
- **避免控制逻辑**：DFD仅关注数据流动，不涉及具体控制流程（如条件分支、循环）。

#### **3. 常见错误**
- **遗漏数据流**：未标识所有必要的数据输入/输出。  
- **过度连接**：单个加工关联过多数据流，导致逻辑混乱。  
- **混淆控制与数据**：错误地将控制信号（如“开始”“结束”）作为数据流。  
- **命名不规范**：使用模糊名称（如“处理数据”），未明确功能。



---

1. **关键定义**：  
   - **MTTF（Mean Time To Failure）**：平均无故障时间，表示系统正常运行到发生故障的平均时间。  
   - **MTTR（Mean Time To Repair）**：平均故障修复时间，表示修复故障所需的平均时间。  
   - **可维护性**：系统在特定时间间隔内可正常进行维护活动的概率。

2. **公式推导**：  
   根据上下文提供的公式：  
   - **可维护性** = 1/(1+MTTR)。  
   - **可靠性** = MTTF/(1+MTTF)。  
   - **可用性** = MTBF/(1+MTBF)（一般MTTR很小，其中 MTBF ≈ MTTF + MTTR）。  


### **知识点整理**
#### **1. 软件可维护性定义**
- **可维护性**：衡量系统在发生故障后，能否在规定时间内通过维护恢复功能的能力。  
- **核心指标**：与 **MTTR（平均故障修复时间）** 直接相关，MTTR越小，可维护性越高。

#### **2. 关键公式**
| 指标       | 公式                          | 说明                                      |
|------------|-------------------------------|-------------------------------------------|
| 可维护性   | $ \frac{1}{1 + MTTR} $      | MTTR越小，分母越接近1，可维护性越高。     |
| 可靠性     | $ \frac{MTTF}{1 + MTTF} $   | MTTF越大，系统越可靠。                    |
| 可用性     | $ \frac{MTBF}{1 + MTBF} $   | MTBF（平均故障间隔时间）= MTTF + MTTR。  |

#### **3. 实际应用**
- **MTTR优化**：缩短故障修复时间是提高可维护性的关键。  
- **MTBF近似**：当MTTR远小于MTTF时，MTBF ≈ MTTF。  
