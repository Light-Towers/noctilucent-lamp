# 软件工程基础/系统开发基础

---
# 增量模型
增量模型作为瀑布模型的一个变体，具有瀑布模型的所有优点。

## 优点
* 第一个可交付版本所需要的成本和时间很少;
* 开发由增量表示的小系统所承担的风险不大;
* 由于很快发布了第一个版本，因此可以减少用户需求的变更;
* 运行增量投资，即在项目开始时，可以仅对一个或两个增量进行投资。

## 缺点
* 如果没有对用户变更的要求进行规划，那么产生的初始量可能会造成后来增量的不稳定;
* 如果需求不像早期思考的那样稳定和完整，那么一些增量就可能需要重新开发，重新发布;
* 管理发生的成本进度和配置的复杂性可能会超出组织的能力。

---
# 软件开发模型

## V模型图示：

<img src="https://raw.githubusercontent.com/Light-Towers/picture/master/noctilucent-lamp/软件模型-V模型图示.png" alt="软件模型-V模型图示.png" style="zoom: 67%;" />

![软件模型-V模型图示_2](https://raw.githubusercontent.com/Light-Towers/picture/master/noctilucent-lamp/软件模型-V模型图示_2.png)

**系统测试和验收测试**针对于**需求分析**；

**集成测试**针对于**概要设计**；

**单元测试针**对于**详细设计**；

**软件实现**应该是针对于**编码**部分；

### 系统设计

#### 概要设计
* 设计软件系统总体结构:基本任务还是采用某种设计方法，将一个复杂的系统按功能划分成模块;确定每个模块的功能;确定模块之间的调用关系;确定模块之间的接口，即模块之间传递的信息;评价模块结构的质量。
* 数据结构及数据库设计:在需求分析阶段对数据的组成、操作约束和数据之间的关系进行了描述，概要设计阶段要加以细化，详细设计阶段则规定具体的实现细节。
* 编写概要设计文档:概要设计说明书、数据库设计说明书、用户手册以及修订测试计划。
* 评审:对设计部分是否完整地实现了需求中规定的功能、性能等要求，设计的可行性，关键的处理以及外部接口定义的正确性、有效性、各部分之间的一致性等都--进行评审。

#### 详细设计
对每个模块进行详细的算法设计，用某种图形、表格和语言等工具将每个模块处理过程的详细算法描述出来。
对模块内的数据结构进行设计。
对数据库进行物理设计，即确定数据库的物理结构。
其他设计:根据软件系统的类型，还可能需要进行代码设计、输入/输出格式设计，用户界面设计等。编写详细设计说明书。
评审:对处理过程的算法和数据库的物理结构都要评审。


软件详细设计阶段的主要任务包括:对模块内的数据结构进行设计;对数据库进行物理设计;对每个模块进行详细的算法设计;代码设计、输入/输出设计、用户界面设计等其他设计。

软件概要设计阶段的主要任务包括:
(1)软件系统总体结构设计，将系统划分成模块;确定每个模块的功能;确定模块之间的调用关系;确定模块之间的接口，即模块之间传递的信息;评价模块结构的质量。
(2)数据结构及数据库设计。



# 需求分析
结构化方法的分析结果由以下几部分组成:一套分层的数据流图、一本数据词典、一组小说明(也称加工逻辑说明)、补充材料。

## 不同阶段的产物
需求分析:数据流图、数据字典
概念设计:ER模型
逻辑设计:关系模式、规范法理论
物理设计:物理特性等

// TODO
**软件工程开发方法**：自顶向下、逐步分解求精、严格区分阶段、阶段产生标准化。

---
# 人机界面设计 —— 黄金三原则
## 1. **用户操纵控制**
- 以不强迫用户进入不必要或不希望的动作的方式来定义交互模式；
- 提供灵活的交互方式；
- 允许中断和撤销用户操作；
- 当用户的技能水平提升时，可以使交互更加流线化，并允许定制化交互；
- 设计应使用户与内部技术细节隔离，直接与屏幕上出现的对象交互。

## 2. **减轻用户的记忆负担**
- 减少对用户短期记忆的需求；
- 建立有意义的默认值；
- 定义直观的快捷方式；
- 界面视觉布局基于现实世界的象征（易于联想）；
- 以逐步进展的方式揭示信息，避免信息过载。

## 3. **保持界面的一致性**
- 允许用户将当前任务置于有意义的上下文中；
- 在应用系统家族中保持一致的交互风格；
- 如果已建立用户熟悉的交互模型，除非有不可抗力，否则不应随意更改。  

---
# 软件质量保证 (ISO/IEC 9126)
![软件质量保证](https://raw.githubusercontent.com/Light-Towers/picture/master/noctilucent-lamp/软件质量保证.png)

## 主要质量特性及子特性
| 质量特性     | 子特性                                                                 |
|--------------|------------------------------------------------------------------------|
| **功能性**   | 适合性、准确性、互用性、依从性、**安全性**                                 |
| **可靠性**   | **成熟性**、容错性、易恢复性                                               |
| **易使用性** | 易理解性、易学性、易操作性                                             |
| **效率**     | 时间特性、资源特性                                                     |
| **可维护性** | 易分析性、易改变性、稳定性、易测试性                                   |
| **可移植性** | 适应性、易安装性、一致性、易替换性                                     |

## 可维护性质量特性详解

### 定义：
可维护性是指与软件维护的难易程度相关的一组软件属性。

### 四个关键子特性：
1. **易分析性**
   - 描述：诊断缺陷或失效原因、判定待修改程度的难易程度。
   
2. **稳定性**
   - 描述：修改造成难以预料的后果的风险程度。
   - 特点：风险程度越低，稳定性越好。

3. **易测试性**
   - 描述：测试已修改软件的难易程度。

4. **易改变性**
   - 描述：修改、排错或适应环境变化的难易程度。

---
# 软件评审
正式的技术评审FTR(FormalTechnical Review)是软件工程师组织的软件质量保证活动，包含以下指导原则：
* 软件评审是评审软件产品，不要涉及对软件生产者能力的评价;
* 评审前要制定严格的评审计划，并严格遵守预计的日程安排;
* 对评审中出现的问题要记录在案，不要过多地讨论解决方案，把问题留给软件生产者来解决;
* 要限制参与者人数，并要求参加评审的人员在评审会之前仔细阅读文档，做好充分的准备。

---
# 软件设计原则

软件设计中遵循“**高内聚、低耦合**”是提高系统可维护性、可扩展性和可理解性的关键原则。

## 一、模块内聚性（Cohesion）

描述：模块内部各组成成分之间的联系紧密程度，从低到高可分为以下几种类型：

| 内聚类型     | 描述                                                                 |
|--------------|----------------------------------------------------------------------|
| **偶然聚合** | 模块完成的动作之间没有任何关系，或者仅仅是非常松散的关系。               |
| **逻辑聚合** | 模块内部的各个组成在**逻辑**上具有相似的处理动作，但**功能用途**上彼此**无关**。 |
| **时间聚合** | 模块内部的各个组成部分所包含的处理动作必须在**同一时间**内执行。             |
| **过程聚合** | 模块内部各个组成部分所要完成的动作虽然没有关系，但必须按**特定的次序**执行。   |
| **通信聚合** | 模块的各个组成部分所完成的动作都使用了**同一个数据**或产生**同一输出数据**。   |
| **顺序聚合** | 模块内部的各个部分，**前一部分**处理动作的**最后输出**是**后一部分**处理动作的**输入**。 |
| **功能聚合** | 模块内部各个部分全部属于一个整体，并执行同一功能，且各部分对实现该功能都必不可少。 |

> ✅ **理想状态为功能聚合**，这是最理想的模块划分方式。

## 二、模块耦合性（Coupling）

描述：模块之间依赖关系的强弱程度，从低到高可分为以下几种类型：

| 耦合类型         | 描述                                                                                     |
|------------------|------------------------------------------------------------------------------------------|
| **非直接耦合**   | 两个模块之间没有直接关系，它们之间的联系完全是通过**主模块**的控制和调用来实现的。              |
| **数据耦合**     | 一组模块借助参数表传递**简单数据**。                                                           |
| **标记耦合**     | 一组模块通过参数表传递记录信息（**数据结构**）。                                                 |
| **控制耦合**     | 模块之间传递的信息中包含用于**控制**模块内部逻辑的信息。                                           |
| **外部耦合**     | 一组模块都访问同一**全局简单变量**，而且不是通过参数表传递该全局变量的信息。                        |
| **公共耦合**     | 多个模块都访问同一个**公共数据环境**（如全局变量、共享数据库等），耦合度较高。                      |
| **内容耦合**     | 最高耦合级别，存在以下任一情况：<br>1. 一个模块直接访问另一个模块的内部数据；<br>2. 一个模块不通过正常入口转到另一个模块的内部；<br>3. 两个模块有一部分程序代码重叠；<br>4. 一个模块有多个入口。 |

> ❌ **内容耦合是最差的设计**，应尽量避免；推荐使用**数据耦合**或更低级别的耦合。

## 三、设计建议

- **追求高内聚**：每个模块应专注于单一职责，尽可能达到**功能聚合**。
- **降低耦合度**：模块间交互应简洁明确，优先选择**数据耦合**，避免**控制耦合**和**内容耦合**。
- **良好的模块化设计**可以提升系统的可维护性、可测试性和可扩展性。

## 四、总结对比

| 维度       | 理想状态        | 不良状态      |
|------------|----------------|---------------|
| 内聚性     | 功能聚合       | 偶然聚合      |
| 耦合性     | 数据耦合       | 内容耦合      |

> 📌 **设计目标**：构建**高内聚、低耦合**的模块结构，以支持系统的长期发展与稳定运行。

---
# 系统测试
## 系统测试方法

### 1.黒盒测试

黒盒测试:等价类划分、边界值分析、错误推测、因果图。
常考的黑盒测试方法:
等价类划分:确定无效与有效等价类，设计用例尽可能多的覆盖有效类，设计用例只覆盖一个无效类。
边界值分析:处理边界情况时最容易出错，选取的测试数据应该恰好等于、稍小于或稍大于边界值。

### 2.白盒测试

白盒测试:语句覆盖、判定覆盖、条件覆盖、条件/判定覆盖、路径覆盖。

|                     | 定义                                                         | 特点                                                         |
| ------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 语句覆盖            | 被测试程序中的每条语句至少执行一次。                         | 对执行逻辑覆盖很低,一般认为是很**弱**的逻辑覆盖。            |
| 判定覆盖 (分支覆盖) | 被测程序每个判定表达式至少获得一次"真"值 和"假"值(或者程序中每一个判定取"真"分 支和取"假"分支至少通过一次。) | 判定覆盖比语句覆盖更强一些。判定 可以是1个条件,也可以是多个条件的组合。 |
| 条件覆盖            | 每一个判定语句中**每个逻辑**条件的各种可能的值至少满足一次。 | 条件覆盖和判断覆盖没有包含关系。                             |
| 判断/条件覆盖       | 判定中每个条件的所有可能取值(真/假)至少 出现一次,并使每个判定本身的判定结果(真/ 假)也至少出现一次。 | 同时满足判定覆盖和条件覆盖。                                 |
| 条件组合覆盖        | 每个判定中的各种可能值的组合都至少出现一 次。                | 同时满足判定覆盖、条件覆盖、判定/ 条件覆盖。                 |
| 路径覆盖            | 覆盖被测试程序中所有可能的路径。                             | 可以对程序进行彻底的测试,比语句 覆盖、条件覆盖、判定覆盖、条件判 定覆盖及条件组合覆盖的覆盖面都 广。 |

### 3.阶段测试

* 验收测试:有效性测试、软件配置审查、验收测试。
* 系统测试:恢复测试、安全性测试、强度测试、性能测试、可靠性测试和安装测试。
* 集成测试:模块间的接口和通信。
单元测试:**模块**接口、**局部**数据结构、边界条件、独立的路径、错误处理。
* 其他测试:回归测试(修改软件后进行的测试，防止引入新的错误)。负载测试(对软件负载能力的测试)。压力测试(对软件超负荷条件下运行情况的测试)。

## 环路复杂度 
环路复杂度公式：V(G)=E-N+2, 其中E为边的数量，N为节点的数量

---
#  数据流图
#### **1. 数据流图（DFD）的核心要素**
- **外部实体（External Entity）**：系统外的数据来源或去向（如用户、其他系统）。  
- **数据流（Data Flow）**：数据在系统内的流动方向（箭头表示）。  
- **加工/处理（Process）**：对数据的变换或操作（圆角矩形表示）。  
- **数据存储（Data Store）**：数据的临时或永久存储（开口矩形表示）。

#### **2. 分层DFD的绘制原则**
- **父图与子图平衡**：子图的输入/输出数据流必须与父图的对应加工一致。  
- **数据守恒**：每个加工必须有输入和输出数据流，避免“黑洞”或“奇迹”。  
- **分解均匀**：每层分解后，各部分复杂度应接近，避免单一分解过细或过粗。  
- **避免控制逻辑**：DFD仅关注数据流动，不涉及具体控制流程（如条件分支、循环）。

#### **3. 常见错误**
- **遗漏数据流**：未标识所有必要的数据输入/输出。  
- **过度连接**：单个加工关联过多数据流，导致逻辑混乱。  
- **混淆控制与数据**：错误地将控制信号（如“开始”“结束”）作为数据流。  
- **命名不规范**：使用模糊名称（如“处理数据”），未明确功能。

---
# 软件可靠性
## 关键定义
   - **MTTF（Mean Time To Failure）**：平均无故障时间，系统正常运行到发生故障的平均时间
   - **MTTR（Mean Time To Repair）**：平均故障修复时间，修复故障所需的平均时间。  
   - **可维护性**：衡量系统在发生故障后，能否在规定时间内通过维护恢复功能的能力  

## 核心指标
   - 可维护性与 MTTR（平均故障修复时间）直接相关
   - MTTR 越小，可维护性越高
   - MTTF 越大，系统越可靠
   - 当 MTTR 远小于 MTTF 时，MTBF ≈ MTTF

## 实际应用
   - **MTTR优化**：缩短故障修复时间是提高可维护性的关键
   - 在计算可用性时，一般认为 MTTR 很小
   - **MTBF近似**：对于 MTBF（平均故障间隔时间），其完整公式为 MTBF = MTTF + MTTR

## 指标对比
|   指标   |           公式            |                 说明                  |
| :------: | :-----------------------: | :-----------------------------------: |
| 可维护性 |  $ \frac{1}{1 + MTTR} $   | MTTR越小，分母越接近1，可维护性越高。 |
|  可靠性  | $ \frac{MTTF}{1 + MTTF} $ |        MTTF越大，系统越可靠。         |
|  可用性  | $ \frac{MTBF}{1 + MTBF} $ | 一般MTTR很小，其中 MTBF ≈ MTTF + MTTR |

---
# 模块设计原则

## 核心概念

### 作用范围（影响范围）
- 定义：受该模块内部一个判定影响的所有模块集合
- 只有某一模块内含有依赖于该判定的操作，那么该模块就在该判定的作用范围内

### 控制范围
- 定义：模块本身以及其所有下属模块（直接或间接从属于它的模块）的集合
- 控制范围完全取决于系统的结构，与模块本身的功能没有直接关系

## 设计规则

1. **作用范围与控制范围的关系**
   - 任何一个判断的作用范围应该是这个判断所在模块的控制范围的一个子集
   - 所有受判断影响的模块应该从属于做出判断的那个模块

2. **层次靠近原则**
   - 受模块M判定影响的模块，最好局限于模块M本身或其直接下属模块
   - 判定所在的模块应在其影响的模块在层次上尽量靠近

## 改进方法
当发现模块作用范围不在其控制范围之内时，可以采用以下方法改进：
1. **上移判点**：将判定上移到更高层的模块
2. **下移受影响模块**：将受判断影响的模块下移到判断所在模块的控制范围内

## 设计目标
- 理想的设计是使一个模块的作用范围在其控制范围之内
- 这样的设计可以保证系统的清晰性和可维护性，避免跨层级的复杂依赖关系

---
# 统一开发过程（RUP）
Rational Unified Process（RUP）是由Rational Software公司开发的一种迭代式软件开发框架，后随公司被IBM收购。它结合了结构化方法和迭代开发的优点，广泛用于复杂项目。

### **核心特点**
1. **迭代与增量开发**
   将项目分解为多个迭代，每个迭代交付可运行版本，逐步完善功能，降低风险。

2. **用例驱动**
   以用户需求（用例）为核心，确保开发始终围绕实际需求展开。

3. **以架构为中心**
   早期确立系统架构，作为设计和决策的基础，保障系统扩展性和稳定性。

4. **风险驱动**
   优先解决高风险问题，通过早期迭代验证关键技术方案。

### **四个阶段**
1. **初始阶段（Inception）**  
   - **目标**：明确项目范围、可行性和商业案例。
   - **里程碑**：生命周期目标
   - **产出**：构想文档、用例模型调查报告、初始业务用例、早期风险评估、阶段与迭代的项目计划。

2. **细化阶段（Elaboration）**  
   - **目标**：建立稳定的系统架构，细化需求与计划。
   - **里程碑**：生命周期架构
   - **产出**：补充需求分析、软件架构描述、可执行的架构原型

3. **构建阶段（Construction）**  
   - **目标**：开发可交付的软件增量，完成主体编码。
   - **里程碑**：最初运作能力
   - **产出**：具备最初运作能力的集成软件产品、用户手册、当前版本的详细描述

4. **移交阶段（Transition）**  
   - **目标**：产品部署、用户培训与反馈整合。
   - **里程碑**：产品发布
   - **产出**：产品发布版本

### **六大最佳实践**
1. **迭代开发**：分阶段验证功能，降低风险。  
2. **需求管理**：通过用例明确需求，减少变更影响。  
3. **组件化架构**：提升复用性，简化维护。  
4. **可视化建模**：使用UML图辅助设计与沟通。  
5. **持续质量验证**：每个迭代均进行测试。  
6. **变更控制**：严格管理需求与设计变更。
