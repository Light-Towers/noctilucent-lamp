![编译过程.png](https://raw.githubusercontent.com/Light-Towers/picture/master/noctilucent-lamp/编译过程.png)

## 🧩 编译过程概述


一个完整的编译过程通常包括以下六个阶段：

### 1. **词法分析（Lexical Analysis）**
- **输入**：`源程序`（字符序列）
- **输出**：`记号流`（Token Stream），即一系列具有类型和值的标记（tokens）
- **任务**：从左到右扫描字符流，识别出一个个单词符号（如关键字、标识符、常量、运算符等）
- **依据**：语言的词法规则
- **常见错误**：
  - 非法字符
  - 单词拼写错误

> ✅ 示例：源程序 `int a = 3 + b;` 被转换为如下记号流：
```bash
KEYWORD(int), IDENTIFIER(a), OPERATOR(=), NUMBER(3), OPERATOR(+), IDENTIFIER(b), SYMBOL(;)
```

### 2. **语法分析（Syntax Analysis）**
- **输入**：记号流（Token Stream）
- **输出**：`分析树`（Parse Tree）或抽象语法树（Abstract Syntax Tree, AST）
- **任务**：根据语法规则，将记号流组织成结构化的语法单位（如表达式、语句、函数体等）
- **依据**：语言的语法规则
- **常见错误**：
  - if...endif 不匹配
  - 少分号、括号不匹配
  - 表达式缺少操作数

> ✅ 分析树是程序语法结构的图形化表示。例如表达式 `a + b * c` 的分析树会体现运算优先级。

---

### 3. **语义分析（Semantic Analysis）**
- **输入**：分析树 / 抽象语法树
- **输出**：带注释的语法树（包含类型信息、变量作用域等）
- **任务**：进行类型检查，确保表达式和语句在语义上合法
- **常见错误**：
  - 运算符与运算对象类型不合法（如浮点数取余）


### 4. **中间代码生成（Intermediate Code Generation）**
- **输入**：带注释的语法树
- **输出**：中间代码（Intermediate Code）
- **任务**：将语法树转换为一种与具体机器无关的中间表示形式，便于后续优化和目标代码生成。
- **常见错误**：
  - 死循环
  - 除以零
  - 数组下标越界

### 5. **代码优化（Code Optimization）**
- **输入**：中间代码
- **输出**：优化后的中间代码
- **任务**：对中间代码进行优化，提高性能。
- **常见优化技术**：
  - 常量折叠：计算常量表达式的值。
  - 死代码消除：移除不会被执行的代码。
  - 循环展开：减少循环控制的开销。
  - 公共子表达式消除：避免重复计算相同的表达式。

### 6. **目标代码生成（Target Code Generation）**
- **输入**：优化后的中间代码
- **输出**：目标机器代码（如汇编或二进制代码）
- **任务**：将中间代码转换为目标机器代码。
- **常见错误**：
  - 指令选择不当
  - 寄存器分配冲突
  - 内存访问效率低

---

## 🔁 编译器与解释器对比

- **不可省略的阶段**（顺序不可交换）：
  - `词法分析`
  - `语法分析`
  - `语义分析`

- **可省略的阶段**：
  - `中间代码生成`
  - `代码优化`

---

## ⚙️ C/C++ 程序构建流程

C/C++ 程序从源码到可执行文件经历以下步骤：

1. **预处理（Preprocessing）**
2. **编译（Compilation）**
3. **汇编（Assembly）**
4. **链接（Linking）**

---

## 📇 符号表（Symbol Table）

- 作用：
  - 收集、记录和使用源程序中相关符号的信息（如变量名、函数名、类型等）。
  - 辅助语义正确性检查和代码生成。

---

## 🚀 函数式程序设计与逻辑式程序设计语言

### 函数式程序设计

- **数据结构**：本质上是表，函数可以作为值出现在表中。
- **控制结构**：依赖于函数及其定义和调用。
- **应用场景**：
  - 符号数据处理（如微分和积分演算、数理逻辑）。
  - 游戏推演。
  - 人工智能及其他领域。

### 逻辑式程序设计语言

- **特点**：无需描述具体的解题过程，只需提供事实和规则。
- **工作原理**：
  - 规则是解决问题的方法的规范说明。
  - 计算机利用谓词逻辑，通过演绎推理得到求解问题的执行序列。
- **应用领域**：
  - 人工智能。
  - 自然语言处理。
  - 数据库查询。
  - 算法描述。
  - 专家系统开发工具。

---
## 💾 运行时数据空间与存储分配策略

| 存储分配策略 | 适用场景 | 生命周期管理 | 特点 | 常见问题 |
|--------------|----------|---------------|------|-----------|
| **静态分配（Static Allocation）** | 静态变量、全局变量 | 程序开始时分配，程序结束时释放 | 内存地址在编译时确定，效率高，但缺乏灵活性 | 不支持递归调用和动态数据结构 |
| **栈分配（Stack Allocation）** | 函数局部变量、参数传递 | 伴随函数调用入栈，函数返回出栈 | 自动管理，生命周期短，速度快 | 栈溢出、递归深度限制 |
| **堆分配（Heap Allocation）** | 动态数据结构（如链表、树） | 显式申请(`malloc/new`)，显式释放(`free/delete`) | 灵活，按需分配，生命周期由程序员控制 | 内存泄漏、悬空指针、碎片化 |

### 补充说明
- **静态分配**：
  - 适用于生命周期固定且在编译时就能确定大小的数据。
  - 多用于全局变量和`static`修饰的局部变量。

- **栈分配**：
  - 用于函数调用中的局部变量和参数传递。
  - 每次函数调用都会创建一个栈帧（stack frame），函数返回后该栈帧被自动销毁。
  - 支持递归，但每次调用都独立占用栈空间，过深递归可能导致栈溢出。

- **堆分配**：
  - 通过动态内存管理机制进行分配和释放。
  - 典型语言特性包括 C 的 `malloc/free` 和 C++ 的 `new/delete`。
  - 若未正确释放内存，会导致内存泄漏；若访问已释放内存，则称为悬空指针错误。

---

## ✅ 总结要点

| 阶段 | 输入 | 输出 | 主要任务 | 检查类型 |
|------|------|------|----------|----------|
| 词法分析 | `源程序`（字符流） | `记号流`（Token Stream） | 扫描字符，识别单词 | 词汇检查 |
| 语法分析 | `记号流` | `分析树`（Parse Tree）或 `AST` | 构建语法结构 | 结构检查 |
| 语义分析 | `分析树`/`AST` | 带类型信息的语法树 | 类型与逻辑检查 | 含义检查 |
| 中间代码生成 | 带注释的语法树 | 中间代码 | 将语法树转换为与具体机器无关的中间表示形式 | 动态语义错误（运行时） |
| 代码优化 | 中间代码 | 优化后的中间代码 | 对中间代码进行优化，提高性能 | - |
| 目标代码生成 | 优化后的中间代码 | 目标机器代码（如汇编或二进制代码） | 将中间代码转换为目标机器代码 | - |

---

## 📌 参考资料

- [软考14-上午题-【程序设计语言基础】-编译、解释程序翻译阶段](https://blog.csdn.net/qq_31532983/article/details/135749497)
