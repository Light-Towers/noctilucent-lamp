# 设计模式
**`背:`** https://blog.csdn.net/qq_52211542/article/details/125648622

## 创建型模式
1. 单例模式(Singleton):保证**一个类只有一个实例**，并**提供**一个访问它的**全局访问点**。关键字：单实例。
2. 工厂方法模式(Factory Method):定义一个**创建对象的接口**，但由**子类决定**需要实例化哪一个类。工厂方法使得子类**实例化的过程推迟**。关键字：动态生产对象。
3. 抽象工厂模式(Abstract Factory):提供一个接口，可以**创建一系列相关或相互依赖的对象**，而无需指定它们具体的类。关键字：生成系列对象。
4. 建造者/构建器模式(Builder):将一个**复杂**类的**表示**与其**构造**相**分离**，使得相同的构建过程能够得出不同的表示。关键字：复杂对象构造
5. 原型模式(Prototype):用原型实例指定创建对象的类型，并且通过拷贝这个原型来创建新的对象。关键字：克隆对象

## 结构型模式
1. 适配器模式(Adapter):将一个类的**接口转换**成用户希望得到的另一种接口。使原本不相容的接口得以协同工作。关键字：转换接口
2. 桥接模式(Bridge):**分离**类的**抽象部分和实现部分**，使他们可以**独立变化**。不希望在抽象和它的实现部分之间有一个固定判定关系。关键字：继承树拆分
3. 组合模式(Composite)：将对象组合成**树形结构**以表示"整体-部分"的层次结构，使得用户对单个对象和组合对象的使用具有一致性。关键字：树形目录结构。
4. 装饰模式(Decorator):**动态**地给一个对象添加一些**额外**的职责。它提供了用子类扩展功能的一个灵活的替代，比派生一个子类更加灵活。关键字：附加职责。
5. 外观模式(Facade):定义一个**高层**接口，为子系统中的一组接口**提供一个一致的外观**，从而**简化**了该子系统的使用。关键字：对外统一接口。
6. 享元模式(Flyweight):提供支持**大量细粒度对象**共享的有效方法。关键字：文章共享文字对象。
7. 代理模式(Proxy):为其他对象**提供一种代理**以**控制**这个对象的访问。关键字：快捷方式。

**口诀**：适桥组装外享代（谐音：石桥组装外享代）

## 行为型模式
1. 职责链模式(Chain of Responsibility):通过给**多个对象处理**请求的机会，**减少**请求的**发送者与接收者**之间的**耦合**。将接收对象链接起来，在链中传递请求，直到有一个对象处理这个请求。关键字：传递职责
2. 命令模式(Command):将一个**请求封装**为**一个对象**，从而可用不同的请求对客户进行**参数化**，将**请求排队**或**记录请求日志**，支持**可撤销**的操作。关键字：日志记录，可撤销。
3. 解释器模式(Interpreter):给定一种语言，定义它的**文法表示**，并定义一个**解释器**，该解释器用来根据文法表示来解释语言中的句子。关键字：虚拟机的机制。
4. 迭代器模式(Itertor):提供一种方法来**顺序**访问一个**聚合对象**中的**各种元素**，而不需要暴露该对象的内部表示。关键字：数据库数据集
5. 中介者模式(Mediator):用一个中介对象来封装一系列的**对象交互**。它使各对象不需要显式地相互调用，从而达到低耦合，还可以**独立**地**改变对象间的交互**。关键字：不直接引用。
6. 备忘录模式(Memento):在**不破坏**封装性的前提下，捕获一个对象的**内部状态**，并在该对象之外保存这个状态，从而可以在以后该对象**恢复**到原先保存的状态。关键字：可恢复。
7. 观察者模式(Observer):定义对象间的一种**一对多**的**依赖**关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。关键字：联动。
8. 状态模式(State):允许一个对象在其内部**状态改变**时**改变**他的**行为**。状态变成类。
9. 策略模式(Strategy):定义一系列**算法**，把它们一个个封装起来，并且使他们之间可**互相替换**，从而让算法可以**独立**于使用它的用户而变化。关键字：多方案切换。
10. 模板方法模式(Template Method):定义一个操作中的算法**骨架**，而将**一些步骤延迟到子类**中，使得子类可以不改变一个算法的结构即可重新定义算法的某些特定步骤。关键字：文档模板填空。
11. 访问者模式(Visitor):表示一个作用于某对象结构中的各元素的操作，使得在**不改变**各元素的类的前提下定义作用于这些元素的**新操作**。关键字：数据与操作分离。

行为型模式对类或对象怎样交互和怎样分配职责进行描述。很多行为模式注重封装变化。当一个程序的某个方面的特征经常发生改变时，这些模式就定义一个封装这个方面的对象。这样，当该程序的其他部分依赖于这个方面时它们都可以与此对象协作。一些模式引入总是被用作参数的对象。有些模式定义一些可作为令牌进行传递的对象,这些对象将在稍后被调用。
在Visitor模式中，一个Visitor对象是一个多态的accept操作的参数，这个操作作用于该Visitor对象访问的对象。
令牌代表一个请求。在Command模式中，
在Memento模式中，它代表在一个对象在某个特定时刻的内部状态。在Command模式和Memento模式这两种情况下，令牌都可以有一个复杂的内部表示，但客户并不会意识到这-点。
在Observer模式中，通过引入Observer和Subject对象来分布通信.

# 7大设计原则
1. 单一职责原则 (Single Responsibility Principle, SRP):目的单一的类，一个类应该只有一个引起它变化的原因。
2. 开闭原则 (Open/Closed Principle, OCP):软件实体（类、模块、函数等）应该对扩展开放，对修改关闭。
3. 里氏替换原则 (Liskov Substitution Principle, LSP):子类必须能够替换其基类，并且程序的行为不会改变。
4. 接口隔离原则 (Interface Segregation Principle, ISP):客户端不应该依赖于它不使用的接口。接口应该尽可能小，只包含一组相关的方法，避免“胖”接口。
5. 依赖倒置原则 (Dependency Inversion Principle, DIP):高层模块不应该依赖低层模块，两者都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。该原则鼓励使用依赖注入等技术来减少组件间的耦合度。
6. 组合重用原则:尽量使用组合，而不是继承关系达到重用目的。
7. 迪米特原则（最少知识法则）：一个对象应当对其他对象有可能少的了解
其他原则：
1. 重用发布等价原则：重用的粒度就是发布的粒度
2. 共同封闭原则：包中的所有类对于同一性质的变化应该是共同封闭的。一个变化若对一个包产生影响，而对其他的包不造成任何影响
3. 共同重用原则：一个包里的所有类应该是共同重用的。如果重用了包里面的一个类，那么就要重用包中的所有类。
4. 无环依赖原则：在包的依赖关系图中不允许存在环，即包之间的结构必须是一个直接的无环图形。
5. 稳定依赖原则：朝着稳定的方向进行依赖。
6. 稳定抽象原则：包的抽象程度应该和其稳定程度一致。

