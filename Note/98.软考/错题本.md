程序设计语言的大多数语法现象可以用CFG(上下文无关文法)表示。下面的CFG产生式集用于描述简单算术表达式，其中+、-、\*表示加、减、乘运算，id表示单个字母表示的变量，那么符合该文法的表达式为()。
P: E->E+T|E-T|T
T->T\*F|F
F->-F|id

```
A.a+-b-c    B.a*(b+c)    C.a*-b+2    D.-a/b+c
```


## 面向对象

已知3个类O、P和Q，类O中定义了一个私有方法F1和一个公有方法F2；类P中定义了一个受保护的方法F3，类P和类Q是类O的派生类，它们的继承方式如下所示：

class P: protected O{...};
class Q: public P{...};

关于方法F1的描述中正确的是();
A.方法F1无法被访问
B.只有在类O内才能访问方法F1
C.只有在类P内才能访问方法F1
D.只有在类Q内才能访问方法F1

关于方法F2的描述中正确的是();
A.类O、P和Q的对象都可以访问方法F2
B.类P和Q的对象都可以访问方法F2
C.类O和Q的对象都可以访问方法F2
D.只有在类P内才能访问方法F2

关于方法F3的描述中正确的是()。
A.类O、P和Q的对象都可以访问方法F3
B.类O、P和Q的对象都不可以访问方法F3
C.类O和Q的对象都可以访问方法F3
D.类P和Q的对象都可以访问方法F3

# 数据结构
在二维平面最近点对问题中，分治法的步骤不包括以下()
A. 计算所有点对的欧氏距离
B. 递归求解左右两半中点集的最近点对问题
C. 按x坐标排序并将点集划分为左右两半
D. 合并时仅需检查距离中线8范围内的点



# 算法

对于一个n阶的对称矩阵A，将其下三角区域(含主对角线)的元素按行存储在一维数组S中，设元素A[i][j]存放在S[k]中，且S[1]=A[0][0]，则k与i，j(i<=j)的对应关系是()。
A. k=i(i+1)/2+j-1
B. k=j(j+1)/2+i+1
C. k=i(i+1)/2+j+1
D. k=j(j+1)/2+i-1

  ![[a8705668c70100dab93737ef2b7c424.jpg]]


()是对稀疏矩阵进行压缩存储的方式。
A. 二维数组和双向链表
B. 三元组顺序表和十字链表
C. 邻接矩阵和十字链表
D. 引顺序表和双向链表


若定义问题的解空间，并以广度优先的方式搜索解空间，则采用的是()算法设计策略。
A.动态规划
B.贪心
C.回溯
D.分支限界


字符串采用链表存储方式时，每个结点存储多个字符有助于提高存储密度。若采用结点大小相同的链表存储串，则串比较、求子串、串连接、串替换等串的基本运算中，()。
A.进行串的比较运算最不方便
B.进行求子串运算最不方便
C.进行串连接最不方便
D.进行串替换最不方便

若栈采用顺序存储方式，现有两栈共享空间V[1..n]， top[i]代表i(i=1,2)个栈的栈顶(两个栈都空时top[1]=1、top[2]=n)，栈1的底在V[1]，栈2的底在V[n]，则栈满(即n个元素暂存在这两个栈)的条件是()。
```
A.top[1] = top[2]
B.top[1]+ top[2]==1
C.top[1]+ top[2]==n
D.top[1]- top[2]== 1
```

# 信息安全
用户B收到用户A带数字签名的消息M，为了验证M的真实性，首先需要从CA获取用户A的数字证书，并利用()验证该证书的真伪，然后利用()验证M的真实性。

问题1
    A.CA的公钥
    B.B的私钥
    C.A的公钥
    D.B的公钥
问题2
    A.CA的公钥
    B.B的私钥
    C.A的公钥
    D.B的公钥


在以阶段划分的编译器中，语义分析阶段的任务包括()
①识别记号 ②识别句子结构 ③检查程序中的语法错误 ④填写符号表 ⑤生成中间代码
A. ②③
B. ③④
C. ①②
D. ④⑤

浮点数加减运算时，()可能导致阶码上溢。
A. 右规
B. 对阶
C. 尾数运算
D. 左规

()用于在网络中向一组特定的设备发送数据包。
A. 网络地址
B. 广播地址
C. 组播地址
D. 单播地址

设链队列Q用含头结点的循环单链表表示，且仅设尾指针rear，假设队列中有n个元素结点，则入队和出队运算的时间复杂度分别为()和()。

编译器将频繁使用的临时变量(如循环计数器)优化到()中，可以提升访问速度。
A. 栈
B. 堆
C. 静态存储区
D. 寄存器

QoS是网络的一种安全机制，确保重要业务量不会延迟或丢弃。通常情况下QoS被部署在()上保证网络的高效运行。
A. 网闸
B. 防火墙
C. 路由器
D. IDS

下列各项中，具有法定时间性的知识产权是()。
①商业秘密权 ②专利权 ③商标权 ④著作权

以下关于数据流图分层结构的叙述中，不正确的是()。
A. 各层数据流图之间应该保持“平衡“关系
B. 顶层数据流图只包含一个处理框，表示待开发的系统
C. 数据流图的层次越多，细节程度越低
D. 分层的数据流图可以清晰的表达系统的层次结构，使得系统更易于理解

()攻击的技术实现路径主要是通过合法开发流程渗透，利用代码混淆、数字证书伪装绕过审查。
A. 零日漏洞
B. 撞库攻击
C. 供应链投毒
D. AI赋能攻击

下列事件中，会触发软件中断的是()。
A. 电源故障
B. 按键输入
C. 除零错误
D. 定时器溢出

某递归算法的时间复杂度计算公式为T(n)=4T(n/2)+nlgn，其中n为问题规模，则该算法的时间复杂度是()
A. O(nlgn)
B. (n^3)
C. O(n^2)
D. o(n^2lgn)

ISO/IEC 25010:2023标准中，()不属于可维护性的子特性。
A. 可修改性(Modifiability)
B. 可分析性(Analysability)
C. 模块化(Modularity)
D. 容错性(Fault Tolerance)

---
### 回溯算法重点与难点解析

#### **重点问题**
1. **核心思想**
   - 通过递归尝试所有可能解，在每一步选择中探索所有可能分支。
   - 若当前路径无法得到合法解，则**回退（Backtrack）**到上一步，尝试其他分支。

2. **经典应用场景**
   - 组合问题（如 `LeetCode 77. 组合`）
   - 排列问题（如 `LeetCode 46. 全排列`）
   - 子集问题（如 `LeetCode 78. 子集`）
   - 数独、八皇后等约束满足问题

3. **终止条件设计**
   - 明确合法解的判定条件（如路径长度等于目标长度）。
   - 避免无限递归（如索引越界或状态重复）。

4. **状态维护**
   - 使用临时变量（如 `path`）记录当前路径。
   - 通过 `used` 数组或哈希表标记已选元素，防止重复使用。

5. **剪枝优化**
   - 提前排除无效分支（如候选值超过目标值、违反约束条件）。
   - 通过排序去重（如 `LeetCode 40. 组合总和 II` 中的重复元素处理）。

#### **难点问题**
1. **递归与回溯的边界控制**
   - 如何设计递归参数传递状态（如起始索引 `start`）？
   - 回溯操作的时机（如 `path.pop()` 或 `used[i] = False`）？

2. **剪枝条件的准确性**
   - 错误剪枝可能导致漏解（如组合总和问题中忽略负数候选值）。
   - 复杂约束条件的逻辑判断（如数独中的行/列/宫格合法性检查）。

3. **时间复杂度分析**
   - 最坏情况下为指数级复杂度（如全排列问题：O(n!)）。
   - 剪枝效果受数据分布影响（如候选值排序后的剪枝效率）。

4. **避免重复解**
   - 同一元素不同顺序的重复（如排列 vs 组合）。
   - 输入含重复元素时的去重（如 `LeetCode 90. 子集 II`）。

5. **空间复杂度优化**
   - 递归栈深度过大导致栈溢出（可改用迭代实现）。
   - 临时变量频繁创建与销毁（如 `path + [nums[i]]` vs 原地修改）。


#### **典型问题与解决方案**
| 问题类型       | 关键点                          | 示例题目                     |
|----------------|---------------------------------|------------------------------|
| **组合问题**   | 起始索引控制、避免重复组合      | `LeetCode 39. 组合总和`      |
| **排列问题**   | 元素唯一性标记、全排列生成      | `LeetCode 47. 全排列 II`     |
| **子集问题**   | 空集处理、重复子集去重          | `LeetCode 90. 子集 II`       |
| **剪枝优化**   | 提前排序候选数组，剪枝无效分支  | `LeetCode 40. 组合总和 II`   |


#### **代码模板示例**
```python
def backtrack(start, path).
    if 满足终止条件.
        res.append(path[.])  # 深拷贝当前路径
        return
    for i in range(start, len(nums)).
        if 剪枝条件.
            continue
        path.append(nums[i])
        backtrack(i + 1, path)  # 递归
        path.pop()              # 回溯
```

#### **注意事项**
- **深拷贝与浅拷贝**：避免将路径引用直接加入结果集（如 `res.append(list(path))`）。
- **参数设计**：通过 `start` 控制搜索范围，避免重复选择。
- **调试技巧**：打印 `path` 和递归层级，观察回溯过程。