## 事务四大特性：ACID

- Atomicity（原子性）：一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部成功提交，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作。
- Consistency（一致性）：数据库总是从一个一致性状态转换到另一个一致状态。
- Isolation（隔离性）：通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的。注意这里的“通常来说”，后面的事务隔离级级别会说到。
- Durability（持久性）：一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，修改的数据也不会丢失。（持久性的安全性与刷新日志级别也存在一定关系，不同的级别对应不同的数据安全级别。）

> - 事务的隔离性是通过锁、MVCC等实现 （[MySQL锁总结](https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s/sSayb346bs7-5IIWTEgV6w)）
> - 事务的原子性、一致性和持久性则是通过事务日志实现（见下）

## 四种隔离级

数据库事务的隔离级别有4种，由低到高分别为Read uncommitted 、Read committed 、Repeatable read 、Serializable 。而且，在事务的并发操作中可能会出现脏读，不可重复读，幻读。

### 概念

**Read uncommitted**：读未提交。一个事务可以读取另一个未提交事务的数据。(会脏读，使用Read committed解决)

**Read committed**：读提交。一个事务要等另一个事务提交后才能读取数据。(会不可重复读，使用Repeatable read解决)

**Repeatable read**：重复读。在开始读取数据（事务开启）时，不再允许修改操作。（会幻读，使用Serializable解决）

**Serializable**：序列化。最高的事务隔离级别，在该级别下，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。但是这种事务隔离级别效率低下，**比较耗数据库性能**，一般不使用。

> 大多数数据库默认的事务隔离级别是Read committed，比如Sql Server , Oracle。**Mysql**的默认隔离级别是Repeatable read。

***

**脏读**（Dirty Reads）：脏读是指一个事务在处理数据的过程中，读取到另一个未提交事务的数据。（事务可能回滚，也就是说未提交的数据可能并不会修改）

**不可重复读**（Non-Repeatable Reads）：对于数据库中的某个数据，一个事务范围内的多次查询却返回了不同的结果，这是由于在查询过程中，数据被另外一个事务修改并提交了。

**幻读**（Phantom Reads）：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这就是发生了幻读。

> * 不可重复读 VS 脏读：脏读读取到的是一个**未提交的数据**，而不可重复读读取到的是**前一个事务提交的数据**。而不可重复读在一些情况也并不影响数据的正确性，比如需要多次查询的数据也是要以最后一次查询到的数据为主。
> * 幻读 VS 不可重复读：都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是**不可重复读查询的都是同一个数据项**，而**幻读针对的是一批数据整体**（比如数据的个数）。
> * 总的来说，解决不可重复读的方法是 锁行，解决幻读的方式是 锁表。


## 锁

数据库中有很多锁，总结一下大概有如下：悲观锁、乐观锁、表锁、行锁、临间锁、间隙锁、记录锁、共享锁、排他锁、意向共享锁、意向排他锁。

* 锁模式分类: 乐观锁、悲观锁

* 范围锁: 行锁、表锁

* 算法锁: 临时锁、间隙锁、记录锁

* 属性锁: 共享锁(S)、排它锁(X)

* 状态锁: 意向共享锁、意向排它锁

### 全局锁
全局锁: 对整个数据库实例加锁。 MySQL 提供了一个加全局读锁的方法，命令是 `Flush tables with read lock (FTWRL)`。

全局锁的典型场景应用场景是全库逻辑备份，也就是把整个库每个表都 select 出来存起来。上面说到全局锁会锁住所有变更语句，但这只是对于 MyISAM 存储引擎而言的。对于 Innodb 而言，其可以利用 MVCC 实现数据的一致性视图，从而不需要锁整个库就可以实现全库的数据备份。

### 行锁

行锁：锁一行或者多行记录，mysql的**行锁是基于索引加载的**

特点：行锁冲突概率低，并发性高，但是会有死锁的情况出现。

### 表锁

在表被锁定期间，其他事务不能对该表进行操作，必须等当前表的锁被释放后才能进行操作。**表锁响应的是非索引字段，即全表扫描**。全表扫描时锁定整张表，可通过执行计划看出扫描了多少条记录。

特点：表锁的锁冲突几率特别高，但降低了死锁的概率。

### 读/写锁

**对于 InnoDB 引擎来说，读锁和写锁可以加在表上，也可以加在行上**。

对于并发读和并发写的问题，可以通过实现一个由两种类型的锁组成的锁系统来解决。这两种类型的锁通常被称为 **共享锁（Shared Lock，S Lock）** 和 **排他锁（Exclusive Lock，X Lock）**，也叫 **读锁（readlock）** 和 **写锁（write lock）**：

- 共享锁 / 读锁：允许事务读（`select`）数据
- 排他锁 / 写锁：允许事务删除（`delete`）或更新（`update`）数据

**读锁是共享的**，或者说是相互不阻塞的。多个事务在同一时刻可以同时读取同一个资源，而互不干扰。

**写锁是排他的**，也就是说一个写锁会阻塞其他的读锁和写锁，这样就能确保在给定的时间里，只有一个事务能执行写入，并防止其他用户读取正在写入的同一资源。

|      |  X 锁  |  S 锁  |
| :--: | :----: | :----: |
| X 锁 | 不兼容 | 不兼容 |
| S 锁 | 不兼容 |  兼容  |

### 意向锁

InnoDB 存储引擎支持 **多粒度（granular）锁定**，就是说**允许事务在行级上的锁和表级上的锁同时存在**。那么为了实现行锁和表锁并存，InnoDB 存储引擎就设计出了 **意向锁（Intention Lock）**。

> Intention locks are **table-level locks** that indicate which type of lock (shared or exclusive) a transaction requires later for a row in a table.

意向锁是一个**表级锁**，其作用就是指明接下来的事务将会用到哪种锁。有两种意向锁：

- **意向共享锁（IS Lock）**：当事务想要获得一张表中某几行的共享锁（行级锁）时，InnoDB 存储引擎会自动地先获取该表的意向共享锁（表级锁）
- **意向排他锁（IX Lock）**：当事务想要获得一张表中某几行的排他锁（行级锁）时，InnoDB 存储引擎会自动地先获取该表的意向排他锁（表级锁）

意向锁之间是相互兼容的：

|       | IS 锁 | IX 锁 |
| :---: | :---: | :---: |
| IS 锁 | 兼容  | 兼容  |
| IX 锁 | 兼容  | 兼容  |

但是与**表级读写锁**之间大部分都是不兼容的：（**意向锁不会与行级读写锁互斥！！！**）

|       |  X 锁  |  S 锁  |
| :---: | :----: | :----: |
| IS 锁 | 不兼容 |  兼容  |
| IX 锁 | 不兼容 | 不兼容 |

问题：

​	1）**为什么没有意向锁的话，表锁和行锁不能共存？**

​	2）**意向锁是如何让表锁和行锁共存的？**

### Mysql中如何加锁

对于 InnoDB 来说，随时都可以加锁，但是并非随时都可以解锁。InnoDB 采用的是**两阶段锁定协议（two-phase locking protocol）**，但是**只有在事务执行 COMMIT 或者 ROLLBACK 的时候才会释放锁**，并且所有的锁是在同一时刻被释放。

|      | 隐式加锁                                                     | 显示加锁                                                     |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 表锁 | DDL 语句（如 `ALTER`、`CREATE` 等），自动给相应的表加表级锁  | lock table user read; # 加表级读锁 <br />unlock tables; # 释放表级锁 |
| 行锁 | DML 语句（如 `UPDATE`、`DELETE` 和 `INSERT`）,自动给相应的记录行加写锁 | `SELECT * FROM table_name WHERE ... FOR UPDATE`，加行级写锁<br />`SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE`，加行级读锁 |



## 索引分类

宏观索引分类：B+树、Hash索引、全文索引

## 存储引擎

|          | InnoDB                         | MyISAM                                        |
| -------- | ------------------------------ | --------------------------------------------- |
| 事务     | 支持                           | 不支持                                        |
| 主键     | 一定要有                       | 不一定要有                                    |
| 外键     | 支持                           | 不支持                                        |
| 聚簇索引 | 是                             | 不是                                          |
| 全文索引 | 不支持(v5.7后也开始支持)       | 支持                                          |
| 行数     | 不存储                         | 存储                                          |
| 行锁     | 支持                           | 不支持                                        |
| 存储文件 | frm(表定义文件)、ibd(数据文件) | frm(表定义文件)、myd(数据文件)、myi(索引文件) |

**聚簇索引**：叶子节点存储行记录。每张表有且仅有一个聚簇索引。

* 如果表定义了主键，则主键就是聚簇索引；

- 如果表没有定义主键，则第一个非空唯一索引（not NULL unique）列是聚簇索引；
- 否则，InnoDB会创建一个隐藏的row-id作为聚簇索引；

**非聚簇索引(辅助索引)**：叶子节点除包含键值外，还包含一个映射(InnoDB是主键，MyISAM是行数据地址指针)。

**联合索引**：表上多个列进行建立索引，本质还是一颗B+树。需满足最左匹配原则

**索引覆盖**：在非聚簇索引中直接得到查询的记录，而不需要再次查询聚集索引中的记录。

**索引下推**(ICP)：在索引遍历过程中，**对索引中包含的字段先做判断，过滤掉不符合条件的记录，减少回表字数**(V5.6)。





#### 减少索引和数据碎片

* 数据碎片的产生：大量删除数据，此时有插入操作。MySQL 会尝试重新使用这部分空间，但是依然无法彻底占用，这样就会产生碎片

- 产生碎片带来的后果当然是，降低查询性能，因为这种情况会导致随机磁盘访问
- 可以通过 OPTIMIZE TABLE 或者重新导入数据表来整理数据



## Refrence

[深入理解数据库行锁与表锁](https://zhuanlan.zhihu.com/p/52678870)

[三分钟入门 InnoDB 存储引擎中的表锁和行锁](https://cloud.tencent.com/developer/article/1850835)

[面试官问你B树和B+树，就把这篇文章丢给他](https://segmentfault.com/a/1190000020416577)
