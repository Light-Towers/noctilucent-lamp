## 什么是IO

现代操作系统将空间划分为用户空间和内核空间。

* **用户空间**: 非内核应用程序运行在用户空间。用户空间中的代码运行在较低的特权级别上，不能直接访问内核空间和硬件设备。
* **内核空间**: 操作系统的核心，是操作系统工作的基础，它负责***管理系统的进程、内存、设备驱动程序、文件和网络系统***，决定着系统的性能和稳定性。

![在这里插入图片描述](https://img-blog.csdnimg.cn/0bc1a87589d54db291321deb8fed7a17.png)

操作系统为了能够稳定运行，应用程序必须通过操作系统提供的API来访问，以达到安全的访问控制。应用程序**发起一次IO访问分为两个阶段**:

  1. IO调用阶段：应用程序向内核发起系统调用。
  2. IO执行阶段：内核执行IO操作并返回。
        2.1 数据准备阶段：内核等待IO设备准备好数据
        2.2 数据拷贝阶段：将数据从内核缓冲区拷贝到用户空间缓冲区

## 五种IO模型

### 1. 阻塞IO

![在这里插入图片描述](https://img-blog.csdnimg.cn/bb4ee792f46042b59f7fe798516fe0a5.png)

应用程序发起一个系统调用（recvform），这个时候应用程序会一直阻塞下去，直到内核把数据准备好，并将其从内核复制到用户空间，复制完成后返回成功提示，这个时候应用程序才会继续处理数据。

* 优点:模型简单，实现难度低,适用于并发量较小的应用开发。
* 缺点:IO调用阶段和IO执行阶段都会阻塞。

> 典型的阻塞I/0模型的例子为data=socket.read(),如果内核数据没有准备就绪,Socket线程就会一直阻塞在read()中等待内核数据就绪。

### 2. 非阻塞IO

![在这里插入图片描述](https://img-blog.csdnimg.cn/2c3167c4e1cb4bb2bae1c5c5bd1b573b.png)

应用进程需要不断询问内核数据是否就绪,在内核数据还未就绪时,应用进程还可以做其他事情。

* 优点:模型简单,实现难度低;与阻塞IO模型对比，它在等待数据报的过程中，进程并没有阻塞，它可以做其他的事情。

* 缺点:轮询发送 recvform,消耗CPU 资源。

### 3. IO复用

![在这里插入图片描述](https://img-blog.csdnimg.cn/8b5a78833a6345f281309efa32291c7a.png)

多个进程的IO注册到一个复用器（select）上，select 会监听所有注册进来的IO。如果内核的数据报没有准备好，调用select 的进程将会被阻塞，而当任一IO在内核缓冲区中有数据，select调用就会返回可读条件，然后进程再进行recvform系统调用，内核将数据拷贝到用户空间，注意这个过程是阻塞的。

注意:IO 复用模型在第一个阶段和第二个阶段其实都有阻塞，第一个阶段阻塞于 select 调用，第二个阶段阻塞于数据复制。

* 优点:适用于高并发应用程序。
* 缺点:模型复杂，实现、开发难度较大。

### 4. 信号驱动IO

![在这里插入图片描述](https://img-blog.csdnimg.cn/937229906fed41abb2f3878cdab6f35e.png)

进程发起一个IO操作，会向内核注册一个信号处理程序，然后立即返回不阻塞，当内核将数据报准备好后会发送一个信号给进程，这时候进程便可以在信号处理程序中调用IO处理数据报。

注意：它与IO复用模型的主要区别是等待数据阶段无阻塞。

* 优点：采用回调机制，等待数据阶段无阻塞；适用于高并发应用程序。
* 缺点：模型较为复杂，实现起来有点儿困难。

### 5. 异步IO

![在这里插入图片描述](https://img-blog.csdnimg.cn/4afa4ff4e3c74fffbf5cb10f9651dbff.png)

当进程发送一个IO操作，进程会立刻返回（不阻塞），内核会把整个IO数据报准备和复制好后，再通知进程，进程再处理数据报，这样在数据复制阶段也不会发生阻塞。

* 优点：整个过程都不阻塞，一步到位；非常使用高并发应用

* 缺点：模型复杂，实现、开发难度较大

### 总结

​	学习IO模型时,必须要把每个模型联系起来看,比如阻塞IO模型会阻塞较长时间,而非阻塞IO在等待数据报的过程中，进程并没有阻塞，它可以做其他的事情。IO复用模型可以很好的降低服务器的压力,且在连接数众多且消息体不大的情况下有很大的优势。

​	五种IO模型，层层递进，一个比一个性能高，当然模型的复杂度也一个比一个复杂。在学习IO模型的过程中我们也可以看出，我们解决的其实就是如何优化数据等待阶段和数据复制阶段这两个问题。

​	最后，用一张图总结五种IO模型的区别。

![在这里插入图片描述](https://img-blog.csdnimg.cn/e879659dddbb4a2bb3ece465b7f9e2ff.png)

![img](https://pdai.tech/images/pics/1492928105791_3.png)



## Refrence

[Java全栈知识体系](https://pdai.tech/md/java/io/java-io-model.html#io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8)

[理解一下5种IO模型、阻塞IO和非阻塞IO、同步IO和异步IO](https://cloud.tencent.com/developer/article/1684951)
