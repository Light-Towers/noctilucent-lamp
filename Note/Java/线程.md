## 线程

start一个线程

* Java线程理解以及openjdk中的实现
  * private native void start0();
  * [源码](http://openjdk.java.net/)（下载到本地看）： openjdk8\hotspot\src\share\vm\runtime
  * 更多底层c++源码
    * openjdk8\jdk\src\share\native\java\lang
    * openjdk8\hotspot\src\share\vm\prims
    * openjdk8\hotspot\src\share\vm\runtime

Java线程分为用户线程和守护线程，线程的daemon属性为true表示是守护线程，false表示是用户线程

* 守护线程：是一种特殊的线程，在后台默默地完成一些系统性的服务，比如垃圾回收线程
* 用户线程：是系统的工作线程，它会完成这个程序需要完成的业务操作

> 当程序中所有用户线程执行完毕之后，不管守护线程是否结束，系统都会自动退出。
>
> 设置守护线程，需要在start()方法之前进行

## CompletableFuture



## 线程中断

> 面试题： 如何停止、中断一个运行中的线程？

**什么是中断？**

1. 首先一个线程不应该由其他线程来强制中断或停止，而是应该由线程自己自行停止。所以，Thread.stop, Thread.suspend, Thread.resume 都已经被废弃了。 
2. 其次在Java中没有办法立即停止一条线程，然而停止线程却显得尤为重要，如取消一个耗时操作。
3. 因此，Java提供了一种用于停止线程的机制——**中断**。 中断只是一种协作机制，Java没有给中断增加任何语法，中断的过程完全需要程序员自己实现。
4. 若要中断一个线程，你需要手动调用该线程的interrupt方法，该方法也仅仅是将线程对象的中断标识设成true；
5. 接着你需要自己写代码不断地检测当前线程的标识位，如果为true，表示别的线程要求这条线程中断，此时究竟该做什么需要你自己写代码实现。 
6. 每个线程对象中都有一个标识，用于表示线程是否被中断；该标识位为true表示中断，为false表示未中断；通过调用线程对象的interrupt方法将该线程的标识位设为true；可以在别的线程中调用，也可以在自己的线程中调用。

**中断相关API**

1. public void interrupt()实例方法。
   * 线程处于正常活动状态，那么会将该线程的中断标志设置为 true，仅此而已。被设置中断标志的线程将继续正常运行，不受影响。所以，interrupt() 并不能真正的中断线程，需要被调用的线程自己进行配合才行。 
   * 线程处于被阻塞状态（例如处于sleep, wait, join 等状态），在别的线程中调用当前线程对象的interrupt方法(中断状态将被清除)，那么线程将**立即退出被阻塞状态**，并抛出一个InterruptedException异常(在catch块中需要再次调用interrupt方法)。 
   * 中断不活动的线程不会产生任何影响

2. public static boolean interrupted()静态方法: 测试当前线程是否被中断（检查中断标志），返回boolean并清除中断状态; 第二次再调用时中断状态已经被清除，将返回一个false。
   * 这个方法做了两件事：1、返回当前线程的中断状态 2、将当前线程的中断状态清0并重设为false。

3. public boolean isInterrupted()实例方法: 判断当前线程是否被中断（通过检查中断标志位）。

<img src="C:\Users\yangjinhua\AppData\Roaming\Typora\typora-user-images\image-20230204103929946.png" alt="image-20230204103929946" style="zoom:80%;" />

> 如果线程处于被阻塞状态（例如处于sleep, wait, join 等状态），在别的线程中调用当前线程对象的interrupt方法，那么线程将立即退出被阻塞状态，并抛出一个InterruptedException异常。 

## LockSupport

`LockSupport`是一个线程阻塞工具类。是用来创建锁和其它同步工具类的基本线程阻塞原语。

LockSupport使用了一种名为Permit（许可）的概念来做到阻塞和唤醒线程的功能，每个线程都有一个许可（permit），**但与Semaphore不同的是，许可的累加上限是1**。

> AQS就是通过调用 LockSupport.park()和 LockSupport.unpark()的方法，来实现线程的阻塞和唤醒的。

```java
public static void park(Object blocker); // 暂停当前线程
public static void parkNanos(Object blocker, long nanos); // 暂停当前线程，不过有超时时间的限制
public static void parkUntil(Object blocker, long deadline); // 暂停当前线程，直到某个时间
public static void park(); // 除非许可证可用，否则禁用当前线程以进行线程调度
public static void parkNanos(long nanos); // 暂停当前线程，不过有超时时间的限制
public static void parkUntil(long deadline); // 暂停当前线程，直到某个时间
public static void unpark(Thread thread); // 如果给定线程尚不可用，则为其提供许可
public static Object getBlocker(Thread t); // 返回被阻塞的程序对象
```

阻塞与唤醒

* Object 的 wait() 、 notify()
  * **必须在synchronized中使用，成对出现**。一个synchronized()代码块中只能有一个线程调用wait()或notify()。顺序：先wait() -> 后notify()。
* Condition 的 await()、signal()
  * **必须在Lock锁块中使用**。顺序：先await() -> 后signal()。
* LockSupport 的 park()、unpark()
  * **park()与unpark()成对出现**。顺序：无要求