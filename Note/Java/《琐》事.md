* 悲观锁：适合写操作多的场景，先加锁可以保证写操作时数据正确。

* 乐观锁：适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。

## 死锁

死锁: 多个线程在执行过程中,因争夺资源而造成的一种互相等待的现象,若无外力干涉那它们都将无法推进下去，如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。 

主要原因：

* 系统资源不足
* 进程运行推进的顺序不合适
* 资源分配不当

如何排查？

* 纯命令：1. jps -l 查看所有java进程 2. jstack 进程编号
* 图形化：jconsole

##  CAS

CAS(Compare And Swap)，是一种无锁算法，具体操作如下：

- 需要读写的内存值 V。
- 进行比较的值 A。
- 要写入的新值 B。

当且仅当 V 的值等于 A 时，CAS通过**原子方式**用新值B来更新V的值（“比较+更新”整体是一个原子操作），否则不会执行任何操作。一般情况下，“更新”是一个不断重试的操作。

源码解析：

```java
// ------------------------- JDK 8 -------------------------
// AtomicInteger.java
// 原子地递增，并返回新值
public final int incrementAndGet() {
  return unsafe.getAndAddInt(this, valueOffset, 1) + 1;
}

// ------------------------- OpenJDK 8 -------------------------
// Unsafe.java
public final int getAndAddInt(Object o, long offset, int delta) {
   int v;
   do {
       // 获取对象o中offset地址处对应的int型字段的值，支持volatile语义
       v = getIntVolatile(o, offset);
       // 拿期望值v与对象o的offset地址处的当前值比较，如果两个值相等，将当前值更新为v + delta，并返回true，否则返回false
       // 底层通过CPU的cmpxchg指令
   } while (!compareAndSwapInt(o, offset, v, v + delta));
   return v;
}
```

整个“比较+更新”操作封装在compareAndSwapInt()中，在JNI里是借助于一个CPU指令cmpxchg完成的，属于原子操作，可以保证多个线程都能够看到同一个变量的修改值。

存在的问题：

1. **ABA问题**。CAS需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。但是如果内存值原来是A，后来变成了B，然后又变成了A，那么CAS进行检查时会发现值没有发生变化，但是实际上是有变化的。ABA问题的解决思路就是在变量前面添加版本号，每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。
   - JDK从1.5开始提供了AtomicStampedReference类来解决ABA问题，具体操作封装在compareAndSet()中。compareAndSet()首先检查当前引用和当前标志与预期引用和预期标志是否相等，如果都相等，则以原子方式将引用值和标志的值设置为给定的更新值。
2. **循环时间长开销大**。CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。
3. **只能保证一个共享变量的原子操作**。对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。
   - Java从1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。

自旋锁在JDK1.4.2中引入，使用-XX:+UseSpinning来开启。如果自旋超过了限定次数（默认是10次，可以使用-XX:PreBlockSpin来更改）没有成功获得锁，就应当挂起线程。JDK 6中变为默认开启，并且引入了自适应的自旋锁（适应性自旋锁）。

自适应意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。

在自旋锁中 另有三种常见的锁形式:TicketLock、CLHlock和MCSlock

## synchronized

* 对象锁(非静态同步方法 OR 代码块)：在方法的前后会有 monitorenter 和 monitorexit 关键字

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/842212a97e4c4c94b473ed2f908771b4~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="image.png" style="zoom:50%;" />

* 静态锁(静态方法带synchronized)：类层级锁, 关键字 ACC_SYNCHRONIZED

<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d5d0cee520c24c35bcd890cedd2b9dd7~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="image.png" style="zoom:50%;" />

**锁升级过程**：无锁 -> 偏向锁 -> 轻量级锁 -> 重量级锁 (锁状态只能升级不能降级)

> Monitor: 可以理解为一个同步工具或一种同步机制，通常被描述为一个对象。每一个Java对象就有一把看不见的锁，称为内部锁或者Monitor锁。
>
> Monitor是**线程私有的数据结构**，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联，同时**monitor中有一个Owner字段存放拥有该锁的线程的唯一标识**，表示该锁被这个线程占用。Monitor是依赖于底层的操作系统的 **Mutex Lock(互斥锁)** 来实现的线程同步。

锁状态对应的 Mark Word 内容

| 锁状态   | 存储内容                                                | 存储内容 |
| :------- | :------------------------------------------------------ | :------- |
| 无锁     | 对象的hashCode、对象分代年龄、是否是偏向锁（0）         | 01       |
| 偏向锁   | 偏向线程ID、偏向时间戳、对象分代年龄、是否是偏向锁（1） | 01       |
| 轻量级锁 | 指向栈中锁记录的指针                                    | 00       |
| 重量级锁 | 指向互斥量（重量级锁）的指针                            | 10       |

## AQS

AQS是一种提供了**原子式管理同步状态**、**阻塞和唤醒线程**功能以及**队列模型**的简单框架。

## 公平锁 VS 非公平锁

公平锁: 是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。

公平锁hasQueuedPredecessors加锁时判断等待队列中是否存在有效节点的方法。如果返回False，说明当前线程可以争取共享资源；如果返回True，说明队列中存在有效节点，当前线程必须加入到等待队列中。



* 优点：等待锁的线程不会饿死
* 缺点：整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。

非公平锁: 是多个线程加锁时直接尝试获取锁，获取不到才会到**等待队列的队尾**等待。

* 优点：可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。
* 缺点：处于等待队列中的线程可能会饿死，或者等很久才会获得锁。

##  可重入锁 VS 非可重入锁

可重入锁: 又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。优点是可一定程度避免死锁。

> Synchronized(隐式锁)和ReentrantLock(显示锁)都是可重入锁。

### 源码解读

首先ReentrantLock和NonReentrantLock都继承父类**AQS**，其父类AQS中维护了一个同步状态status来计数重入次数，status初始值为0。

* 获取锁: 可重入锁先尝试获取并更新status值，如果status == 0表示没有其他线程在执行同步代码，则把status置为1，当前线程开始执行。如果status != 0，则判断当前线程是否是获取到这个锁的线程，如果是的话执行status+1，且当前线程可以再次获取锁; 而非可重入锁是直接去获取并尝试更新当前status的值，如果status != 0的话会导致其获取锁失败，当前线程阻塞。

* 释放锁: 可重入锁同样先获取当前status的值，在当前线程是持有锁的线程的前提下。如果status-1 == 0，则表示当前线程所有重复获取锁的操作都已经执行完毕，然后该线程才会真正释放锁; 而非可重入锁则是在确定当前线程是持有锁的线程之后，直接将status置为0，将锁释放。

![img](https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/32536e7a.png)

## 独享锁 VS 共享锁



无锁 -> 独占锁 -> 读写锁 -> 邮戳锁