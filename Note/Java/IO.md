## BIO

在读写数据过程中会发生阻塞现象。当用户线程发出IO 请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用户线程交出CPU。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才解除 block 状态。

## 非阻塞IO

当用户线程发起一个read 操作后，并不需要等待，而是马上就得到了一个结果。如果结果是一个error 时，它就知道数据还没有准备好，于是它可以再次发送read 操作。一旦内核中的数据准备
好了，并且又再次收到了用户线程的请求，那么它马上就将数据拷贝到了用户线程，然后返回。所以事实上，在非阻塞IO 模型中，用户线程需要不断地询问内核数据是否就绪，也就说非阻塞IO不会交出CPU，而会一直占用CPU。

## 多路复用IO 模型

有一个线程不断去轮询多个socket 的状态，只有当socket 真正有读写事件时，才真正调用实际的 IO 读写操作。用一个线程就可以管理多个socket。

优点：效率比非阻塞IO模型高, 因为在非阻塞IO 中，不断地询问socket 状态是通过用户线程去进行的，而在多路复用IO 中，轮询每个socket 状态是内核在进行的，这个效率要比用户线程要高的多。

缺点：一旦事件响应体很大，那么就会导致后续的事件迟迟得不到处理，并且会影响新的事件轮询。

## 信号驱动IO 模型

当用户线程发起一个IO 请求操作，会给对应的socket 注册一个信号函数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号之后，便在信号函数中调用IO 读写操作来进行实际的IO 请求操作。

## 异步IO 模型

当用户线程发起read 操作之后，立刻就可以开始去做其它的事。而另一方面，从内核的角度，当它受到一个asynchronous read 之后，它会立刻返回，说明read 请求已经成功发起了，因此不会对用户线程产生任何block。