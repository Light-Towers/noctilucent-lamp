## 错误总结
**MalformedPOSTRequest**
The body of your POST request is not well-formed multipart/form-data

* 错误原因：PostObject请求中表单域格式不符合要求。
表单要求如下：
* Header必须包含Content-Type: multipart/form-data; boundary={boundary}。
* Header和Body之间由\r\n--{boundary} 分割。\r\n显示为换行。
* 表单域名称大小写敏感，如policy、key、file、OSSAccessKeyId、OSSAccessKeyId、Content-Disposition。
* 表单域file必须为最后一个表单域。
* Bucket为public-read-write时，可以不指定表单域OSSAccessKeyId、policy、Signature。如果指定了其中一个，则无论Bucket是否为public-read-write，都必须指定另外两个。


## 文件上传（multipart/form-data）重构说明

本文档整理常见的浏览器/客户端向服务端提交文件时，基于 multipart/form-data 的请求规范、常见错误与排查步骤，便于前端和后端快速定位问题。

### 1 概述
multipart/form-data 是在 HTML 表单或程序化上传中，用于提交二进制文件和文本字段的常用编码格式。服务器端（例如对象存储服务 OSS）通常对表单字段顺序、header、boundary、签名等有严格要求。

### 2 必要的请求要素（Checklist）
- Content-Type header：必须为 `multipart/form-data; boundary={boundary}`，注意 boundary 前后没有引号。
- 请求体格式：由若干表单域组成，每个表单域之前由 `--{boundary}\r\n` 分隔，表单结束以 `--{boundary}--` 结尾。
- 每个表单域以 `Content-Disposition: form-data; name="FIELDNAME"` 开头，若为文件域需同时包含 `filename="..."`。可选的 `Content-Type: mime/type` 紧随其后，再空一行后写入内容。
- 表单域名称大小写敏感（例如 `policy`、`key`、`file`、`OSSAccessKeyId`、`Signature` 等）。
- 文件域 `file` 必须放在所有普通表单域之后（即最后一个表单域），某些存储服务要求文件为最后一项。

### 3 常见错误与排查（以 MalformedPOSTRequest 为例）
- 错误表现：返回 400，错误信息为 "MalformedPOSTRequest" 或提示 body 格式不正确。
- 典型原因：
	- Header 缺少或错误的 Content-Type（boundary 丢失或不匹配）。
	- boundary 与请求体中实际分隔符不一致（大小写、前后多/少 `--`、缺少 CRLF）。
	- 表单域顺序不满足后端/服务要求（例如 file 不是最后一个域）。
	- 表单域名称拼写或大小写错误。
	- multipart 格式中某个表单域没有正确以 CRLF 分隔（Windows 下注意 CRLF 与 LF 区别）。

排查步骤：
1. 用抓包工具（浏览器 Network、Fiddler、Wireshark、tcpdump）或后端打印请求原始 body，确认 boundary 值和 body 的分隔符一致。注意 body 中的每个分隔符前应为 `\r\n--{boundary}`（表单开始处可无前置 CRLF，但域间必须）。
2. 检查 Content-Type header 是否包含 `boundary=`，并与 body 中 `--{boundary}` 完全匹配。
3. 验证表单域名及顺序，确保 `file` 在最后，签名类字段（例如 `policy`、`OSSAccessKeyId`、`Signature`）齐全且拼写正确（某些公开 bucket 可省略，但三者不可只写其一）。
4. 在服务端或代理处打印原始请求（包括二进制）以排除中间代理修改 header 的可能性。
5. 简化复现：先提交仅有一个文本域的 multipart 请求，确认服务端能接受，再逐步增加字段和文件，定位出错点。

### 4 前端示例
1) 浏览器原生 FormData

```js
const form = new FormData();
form.append('policy', policyValue);
form.append('OSSAccessKeyId', accessKeyId);
form.append('Signature', signature);
// 其他字段
form.append('key', objectKey);
// file 必须放最后
form.append('file', fileInput.files[0]);

fetch(uploadUrl, {
	method: 'POST',
	body: form, // 浏览器会自动设置合适的 Content-Type 和 boundary
});
```

注意：使用原生 FormData 时不要手动设置 Content-Type header（浏览器 会自动包含 boundary）；手动设置很容易导致 boundary 不匹配的问题。

2) 手工构造 multipart body（程序化，需正确管理 boundary 和 CRLF）

示例伪代码（需在后端或脚本中严格控制 CRLF）：

```
--{boundary}\r\n
Content-Disposition: form-data; name="policy"\r\n\r\n
{policy}\r\n
--{boundary}\r\n
Content-Disposition: form-data; name="file"; filename="a.jpg"\r\n
Content-Type: image/jpeg\r\n\r\n
<binary data>\r\n
--{boundary}--\r\n
```

### 5 后端/代理注意点
- 反向代理（nginx、CDN）可能会更改或删除部分 header，导致 boundary 丢失或 Content-Type 不一致。必要时直接查看后端接收的原始请求。 
- 检查服务器框架对 multipart 的解析器（例如 Java 的 Commons FileUpload、Spring MultipartResolver、Node 的 multer 等）配置，确保上传大小、编码与 field 名称允许。

### 6 调试技巧
- 对比成功与失败请求的 raw body（抓包或后端日志）。
- 在本地用 curl 构造相同请求进行复现（注意 Windows 下 cmd 语法）：

```bat
curl -i -X POST "https://example.com/upload" -F "policy=%POLICY%" -F "OSSAccessKeyId=%KEY%" -F "Signature=%SIGN%" -F "key=path/to/obj" -F "file=@C:\path\to\file.jpg"
```

- 如果使用 SDK（如 OSS SDK），优先使用 SDK 提供的方法上传，避免手工构造 multipart body。

### 7 参考
- 阿里云 OSS 错误文档（MalformedPOSTRequest）：https://help.aliyun.com/zh/oss/support/http-400-status-code#section-zev-rjh-1r7
