# 微信支付开发文档

## 一、微信官方文档

> **微信支付API稳定版本区别: V3与V2的主要区别**
> 1. 遵循统一的REST的设计风格
> 2. 使用JSON作为数据交互的格式，不再使用XML
> 3. 使用基于非对称密钥的SHA256-RSA的数字签名算法，不再使用MD5或HMAC-SHA256
> 4. 签名需要使用商户API证书进行签名。具体可参考[什么是商户API证书如何获取？](https://pay.weixin.qq.com/doc/v3/merchant/4013053053)
> 5. 验签支持2种方式：
>    - **微信支付公钥模式（推荐使用）**：商户在验证微信支付API应答和回调通知的签名时需要用到微信支付公钥，且商户可以按需更新微信支付公钥。
>    - 平台证书模式：商户在验证微信支付API应答和回调通知的签名时需要用到平台证书，平台证书的有效期为5年，商户需每5年更新一次，对系统实现要求较高，推荐使用微信支付公钥模式。
> 6. 使用AES-256-GCM，对回调中的关键信息进行加密保护

### 1. 支付方式说明

#### 1.1 普通支付方式

| 支付方式 | 使用场景 | 官方文档 |
|---------|---------|---------|
| JSAPI支付 | 微信客户端内部浏览器 | [JSAPI支付文档](https://pay.weixin.qq.com/doc/v3/merchant/4012062524) |
| APP支付 | APP | [APP支付](https://pay.weixin.qq.com/doc/v3/merchant/4013070158) |
| H5支付 | 手机浏览器网页（非微信客户端内部浏览器） | [H5支付文档](https://pay.weixin.qq.com/doc/v3/merchant/4012791832) |
| Native支付 | PC端网页浏览器 | [Native支付](https://pay.weixin.qq.com/doc/v3/merchant/4012791874) |
| 小程序支付 | 微信小程序 | [小程序支付](https://pay.weixin.qq.com/doc/v3/merchant/4012791894) |

#### 1.2 特殊支付方式

| 支付方式 | 说明 | 官方文档 |
|---------|------|---------|
| 合单支付 | 将多个商户的订单（普通商户模式支持2-10笔订单）合并为一个订单进行支付的能力 | [合单支付](https://pay.weixin.qq.com/doc/v3/merchant/4012077203) |
| 付款码支付 | 刷卡支付方式 | [付款码支付(V2)](https://pay.weixin.qq.com/doc/v2/merchant/4011936234) |
| 刷脸支付 | 基于人脸识别的支付方式 | [刷脸支付平台](https://pay.weixin.qq.com/wiki/doc/wxfacepay/product/) |

### 2. JSAPI支付实现指南

JSAPI支付流程配置：

![JSAPI支付流程](https://gtimg.wechatpay.cn/resource/xres/mmpaydoc/static/img/9c5784caea8475b67cfe55141aba2d4f.png)

![img](https://gtimg.wechatpay.cn/resource/xres/mmpaydoc/static/img/713850c0595731717d544152b686b5ab.png)

#### 2.1 支付流程

微信JSAPI支付的主要流程如下：

1. 商户下单：商户后端调用[JSAPI/小程序下单](https://pay.weixin.qq.com/doc/v3/merchant/4012791856)接口获取预支付ID（prepay_id）

   1. `openid`：用户在商户下单的appid下唯一标识，获取方式详见[参数说明](https://pay.weixin.qq.com/doc/v3/merchant/4012068676)。
   2. `time_expire`：支付结束时间。若传递该参数，则用户只能在订单设置的支付结束时间`time_expire`之前进行支付，超过支付结束时间后，用户支付将收到："订单已超过商户设置的最晚支付成功时间，请重新发起支付"的提示，商户需对订单进行关单处理。若不传该参数，默认订单支付有效期为7天，用户可在7天内进行支付，超出7天，订单将被关闭。
   3. `prepay_id`：预支付交易会话标识。调起支付时需要使用的参数，`prepay_id`有效期为2小时，超过2小时，**商户需要使用原下单参数重新请求下单接口**，获取新的`prepay_id`。

2. 商户调起支付：微信客户端前端页面调用[WeixinJSBridge](https://pay.weixin.qq.com/doc/v3/merchant/4012791857)对象方法调起微信支付界面

   1. 商户调起支付前，确保已在[商户平台](https://pay.weixin.qq.com/)配置好JSAPI支付授权目录（只有[配置了JSAPI支付授权目录](https://pay.weixin.qq.com/doc/v3/merchant/4013287088)的网页才能调起支付）
   2. 然后通过调用微信浏览器内置对象方法来调起微信收银台，具体请参考[JSAPI调起支付](https://pay.weixin.qq.com/doc/v3/merchant/4012791857)

3. 用户支付：用户在完成支付/取消支付，返回商户前端页面后，微信浏览器内置对象方法会收到回调，此时商户需要调[查询订单API](https://pay.weixin.qq.com/doc/v3/merchant/4012791859)接口确认订单状态，并根据订单状态向用户展示支付结果。

   同时，如果用户支付成功，微信支付系统会向商户发送[支付成功回调](https://pay.weixin.qq.com/doc/v3/merchant/4012791861)。未收到回调时，商户也可调用[查询订单API](https://pay.weixin.qq.com/doc/v3/merchant/4012791859)接口确认订单状态。具体实现方案商户可以参考[支付回调和查单实现指引](https://pay.weixin.qq.com/doc/v3/merchant/4012075249)。

   

#### 2.2 后端核心代码实现

##### 2.2.1 微信支付配置类 (WeChatPayConfig.java)

```java
import java.security.PrivateKey;
import java.security.cert.X509Certificate;

/**
 * 微信支付配置类
 * 存储微信支付所需的各种配置信息
 */
public class WeChatPayConfig {
    
    // 应用ID
    private String appId;
    
    // 商户号
    private String mchId;
    
    // 商户证书序列号
    private String mchSerialNo;
    
    // 商户私钥
    private PrivateKey privateKey;
    
    // 微信支付平台证书
    private X509Certificate platformCertificate;
    
    // 支付通知URL
    private String notifyUrl;
    
    // APIv3密钥
    private String apiV3Key;
    
    // 微信支付API域名
    private String domain = "https://api.mch.weixin.qq.com";
    
    public WeChatPayConfig() {
    }
    
    public WeChatPayConfig(String appId, String mchId, String mchSerialNo, 
                          PrivateKey privateKey, String notifyUrl, String apiV3Key) {
        this.appId = appId;
        this.mchId = mchId;
        this.mchSerialNo = mchSerialNo;
        this.privateKey = privateKey;
        this.notifyUrl = notifyUrl;
        this.apiV3Key = apiV3Key;
    }
    
    // Getters and Setters
    
    public String getAppId() {
        return appId;
    }
    
    public void setAppId(String appId) {
        this.appId = appId;
    }
    
    public String getMchId() {
        return mchId;
    }
    
    public void setMchId(String mchId) {
        this.mchId = mchId;
    }
    
    public String getMchSerialNo() {
        return mchSerialNo;
    }
    
    public void setMchSerialNo(String mchSerialNo) {
        this.mchSerialNo = mchSerialNo;
    }
    
    public PrivateKey getPrivateKey() {
        return privateKey;
    }
    
    public void setPrivateKey(PrivateKey privateKey) {
        this.privateKey = privateKey;
    }
    
    public X509Certificate getPlatformCertificate() {
        return platformCertificate;
    }
    
    public void setPlatformCertificate(X509Certificate platformCertificate) {
        this.platformCertificate = platformCertificate;
    }
    
    public String getNotifyUrl() {
        return notifyUrl;
    }
    
    public void setNotifyUrl(String notifyUrl) {
        this.notifyUrl = notifyUrl;
    }
    
    public String getApiV3Key() {
        return apiV3Key;
    }
    
    public void setApiV3Key(String apiV3Key) {
        this.apiV3Key = apiV3Key;
    }
    
    public String getDomain() {
        return domain;
    }
    
    public void setDomain(String domain) {
        this.domain = domain;
    }
}
```

##### 2.2.2 微信JSAPI支付服务类 (WeChatJsApiPaymentService.java)

```java
import java.security.Signature;
import java.security.PrivateKey;
import java.security.MessageDigest;
import java.security.cert.X509Certificate;
import java.util.*;
import java.nio.charset.StandardCharsets;
import java.util.Base64;

/**
 * 微信JSAPI支付服务类
 * 实现微信JSAPI支付的完整流程，包括下单、签名、调起支付和回调处理
 */
public class WeChatJsApiPaymentService {
    
    // 微信支付相关配置
    private String appId;           // 公众号AppID
    private String mchId;           // 商户号
    private PrivateKey privateKey;  // 商户私钥
    private String certSerialNo;    // 商户证书序列号
    private String notifyUrl;       // 支付结果通知地址
    
    public WeChatJsApiPaymentService(String appId, String mchId, PrivateKey privateKey, 
                                   String certSerialNo, String notifyUrl) {
        this.appId = appId;
        this.mchId = mchId;
        this.privateKey = privateKey;
        this.certSerialNo = certSerialNo;
        this.notifyUrl = notifyUrl;
    }
    
    /**
     * JSAPI下单接口
     * 
     * @param openid 用户在商户appid下的唯一标识
     * @param outTradeNo 商户订单号
     * @param amount 订单金额，单位为分
     * @param description 商品描述
     * @param timeExpire 订单失效时间，格式为YYYY-MM-DDTHH:mm:ss+TIMEZONE
     * @return 预支付交易会话标识(prepay_id)
     */
    public Map<String, String> createOrder(String openid, String outTradeNo, int amount, 
                                          String description, String timeExpire) {
        // 构造下单请求参数
        Map<String, Object> requestData = new HashMap<>();
        requestData.put("appid", appId);
        requestData.put("mchid", mchId);
        requestData.put("description", description);
        requestData.put("out_trade_no", outTradeNo);
        requestData.put("time_expire", timeExpire);
        requestData.put("notify_url", notifyUrl);
        
        // 设置订单金额
        Map<String, Object> amountInfo = new HashMap<>();
        amountInfo.put("total", amount);
        amountInfo.put("currency", "CNY");
        requestData.put("amount", amountInfo);
        
        // 设置支付者信息
        Map<String, Object> payerInfo = new HashMap<>();
        payerInfo.put("openid", openid);
        requestData.put("payer", payerInfo);
        
        // TODO: 实际调用微信支付下单接口
        // 这里应该通过HTTP请求调用微信支付V3下单接口
        // POST https://api.mch.weixin.qq.com/v3/pay/transactions/jsapi
        
        // 模拟返回结果
        Map<String, String> result = new HashMap<>();
        result.put("prepay_id", "wx201410272009395522657a690389285100");
        return result;
    }
    
    /**
     * 生成JSAPI调起支付所需参数
     * 
     * @param prepayId 预支付交易会话标识
     * @return 调起支付所需参数
     */
    public Map<String, String> generatePayParams(String prepayId) {
        Map<String, String> payParams = new HashMap<>();
        payParams.put("appId", appId);
        payParams.put("timeStamp", String.valueOf(System.currentTimeMillis() / 1000));
        payParams.put("nonceStr", generateNonceStr());
        payParams.put("package", "prepay_id=" + prepayId);
        payParams.put("signType", "RSA");
        
        // 生成签名
        String paySign = generatePaySign(payParams);
        payParams.put("paySign", paySign);
        
        return payParams;
    }
    
    /**
     * 生成支付签名
     * 
     * @param payParams 支付参数
     * @return 签名值
     */
    private String generatePaySign(Map<String, String> payParams) {
        try {
            // 构造签名串
            StringBuilder signBuilder = new StringBuilder();
            signBuilder.append(payParams.get("appId")).append("\n");
            signBuilder.append(payParams.get("timeStamp")).append("\n");
            signBuilder.append(payParams.get("nonceStr")).append("\n");
            signBuilder.append(payParams.get("package")).append("\n");
            
            String message = signBuilder.toString();
            
            // 使用SHA256 with RSA签名
            Signature sign = Signature.getInstance("SHA256withRSA");
            sign.initSign(privateKey);
            sign.update(message.getBytes(StandardCharsets.UTF_8));
            byte[] signedBytes = sign.sign();
            
            // Base64编码
            return Base64.getEncoder().encodeToString(signedBytes);
        } catch (Exception e) {
            throw new RuntimeException("签名生成失败", e);
        }
    }
    
    /**
     * 生成随机字符串
     * 
     * @return 随机字符串
     */
    private String generateNonceStr() {
        String chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
        StringBuilder sb = new StringBuilder();
        Random random = new Random();
        for (int i = 0; i < 32; i++) {
            sb.append(chars.charAt(random.nextInt(chars.length())));
        }
        return sb.toString();
    }
    
    /**
     * 验证微信支付回调通知签名
     * 
     * @param timestamp 时间戳
     * @param nonce 随机字符串
     * @param body 通知报文主体
     * @param signature 签名
     * @param certificate 微信支付平台证书
     * @return 签名是否有效
     */
    public boolean verifyNotifySign(String timestamp, String nonce, String body, 
                                  String signature, X509Certificate certificate) {
        try {
            // 构造验签串
            StringBuilder signBuilder = new StringBuilder();
            signBuilder.append(timestamp).append("\n");
            signBuilder.append(nonce).append("\n");
            signBuilder.append(body).append("\n");
            
            String message = signBuilder.toString();
            
            // 使用微信支付平台证书验证签名
            Signature sign = Signature.getInstance("SHA256withRSA");
            sign.initVerify(certificate);
            sign.update(message.getBytes(StandardCharsets.UTF_8));
            
            byte[] signedBytes = Base64.getDecoder().decode(signature);
            return sign.verify(signedBytes);
        } catch (Exception e) {
            throw new RuntimeException("签名验证失败", e);
        }
    }
    
    /**
     * 处理支付结果通知
     * 
     * @param notifyData 通知数据
     * @return 处理结果
     */
    public String handlePayNotify(Map<String, Object> notifyData) {
        try {
            // 解析通知数据
            String outTradeNo = (String) notifyData.get("out_trade_no");  // 商户订单号
            String transactionId = (String) notifyData.get("transaction_id");  // 微信支付订单号
            String tradeState = (String) notifyData.get("trade_state");  // 交易状态
            
            // 根据交易状态处理业务逻辑
            if ("SUCCESS".equals(tradeState)) {
                // 支付成功，更新订单状态等业务处理
                System.out.println("订单支付成功: " + outTradeNo);
                // TODO: 更新数据库订单状态等操作
            } else if ("CLOSED".equals(tradeState)) {
                // 订单已关闭
                System.out.println("订单已关闭: " + outTradeNo);
                // TODO: 更新数据库订单状态等操作
            } else if ("REFUND".equals(tradeState)) {
                // 订单转入退款
                System.out.println("订单转入退款: " + outTradeNo);
                // TODO: 更新数据库订单状态等操作
            }
            
            // 返回成功响应
            Map<String, String> response = new HashMap<>();
            response.put("code", "SUCCESS");
            response.put("message", "成功");
            
            return "{\"code\":\"SUCCESS\",\"message\":\"成功\"}";
        } catch (Exception e) {
            // 返回失败响应
            return "{\"code\":\"FAIL\",\"message\":\"失败\"}";
        }
    }
}
```

##### 2.2.3 微信支付控制器类 (WeChatPayController.java)

```java
import org.springframework.web.bind.annotation.*;
import org.springframework.http.ResponseEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RestController;

import java.util.Map;
import java.util.HashMap;
import java.security.PrivateKey;
import java.security.cert.X509Certificate;

/**
 * 微信支付控制器
 * 处理微信JSAPI支付的下单请求和支付回调
 */
@RestController
@RequestMapping("/api/wechat/pay")
public class WeChatPayController {
    
    // 注入微信支付服务
    private final WeChatJsApiPaymentService weChatPayService;
    
    public WeChatPayController() {
        // 初始化服务，实际项目中应该通过依赖注入
        // 这里使用模拟的参数
        this.weChatPayService = new WeChatJsApiPaymentService(
            "your-appid", 
            "your-mchid", 
            (PrivateKey) null, // 实际应该传入商户私钥
            "your-cert-serial-no", 
            "https://your-domain.com/api/wechat/pay/notify"
        );
    }
    
    /**
     * JSAPI支付下单接口
     * 
     * @param request 下单请求参数
     * @return 调起支付所需参数
     */
    @PostMapping("/jsapi")
    public ResponseEntity<Map<String, Object>> createJsApiOrder(@RequestBody Map<String, Object> request) {
        try {
            // 从请求中获取参数
            String openid = (String) request.get("openid");
            String outTradeNo = (String) request.get("out_trade_no");
            Integer amount = (Integer) request.get("amount");
            String description = (String) request.get("description");
            String timeExpire = (String) request.get("time_expire");
            
            // 调用微信支付下单接口获取prepay_id
            Map<String, String> orderResult = weChatPayService.createOrder(
                openid, outTradeNo, amount, description, timeExpire);
            
            String prepayId = orderResult.get("prepay_id");
            
            // 生成调起支付所需参数
            Map<String, String> payParams = weChatPayService.generatePayParams(prepayId);
            
            // 构造返回结果
            Map<String, Object> result = new HashMap<>();
            result.put("code", 0);
            result.put("message", "success");
            result.put("data", payParams);
            
            return ResponseEntity.ok(result);
        } catch (Exception e) {
            Map<String, Object> errorResult = new HashMap<>();
            errorResult.put("code", -1);
            errorResult.put("message", "支付下单失败: " + e.getMessage());
            return ResponseEntity.status(500).body(errorResult);
        }
    }
    
    /**
     * 微信支付结果通知回调接口
     * 
     * @param headers 请求头
     * @param body 通知报文主体
     * @return 处理结果
     */
    @PostMapping("/notify")
    public ResponseEntity<String> handlePayNotify(
            @RequestHeader HttpHeaders headers,
            @RequestBody String body) {
        
        try {
            // 获取微信支付回调通知中的签名信息
            String timestamp = headers.getFirst("Wechatpay-Timestamp");
            String nonce = headers.getFirst("Wechatpay-Nonce");
            String signature = headers.getFirst("Wechatpay-Signature");
            String serial = headers.getFirst("Wechatpay-Serial");
            
            // TODO: 根据serial获取对应的微信支付平台证书
            X509Certificate certificate = null; // 实际应该获取对应证书
            
            // 验证签名
            boolean isValid = weChatPayService.verifyNotifySign(timestamp, nonce, body, signature, certificate);
            
            if (!isValid) {
                // 签名验证失败
                return ResponseEntity.badRequest()
                    .body("<xml><code>FAIL</code><message>签名验证失败</message></xml>");
            }
            
            // 解析body中的JSON数据
            // 实际应该使用JSON解析库，如Jackson或Gson
            // 这里简化处理，模拟解析结果
            Map<String, Object> notifyData = new HashMap<>();
            // TODO: 实际应该解析body中的JSON数据
            notifyData.put("out_trade_no", "1217752501201407033233368018");
            notifyData.put("transaction_id", "1217752501201407033233368018");
            notifyData.put("trade_state", "SUCCESS");
            
            // 处理支付结果通知
            String response = weChatPayService.handlePayNotify(notifyData);
            
            return ResponseEntity.ok()
                .header("Content-Type", "application/json")
                .body(response);
        } catch (Exception e) {
            return ResponseEntity.status(500)
                .body("<xml><code>FAIL</code><message>处理失败</message></xml>");
        }
    }
}
```

#### 2.3 前端JavaScript实现

##### 2.3.1 微信JSAPI支付前端代码 (wechat-jsapi-payment.js)

```java
/**
 * 调用微信JSAPI支付
 * @param {Object} payParams - 支付参数，由后端生成
 */
function callWeChatPay(payParams) {
    // onBridgeReady
    function onBridgeReady() {
        WeixinJSBridge.invoke('getBrandWCPayRequest', {
            "appId": payParams.appId,     //公众号ID，由商户传入
            "timeStamp": payParams.timeStamp, //时间戳，自1970年以来的秒数
            "nonceStr": payParams.nonceStr, //随机串; e61463f8efa94090b1f366cccfbbb444
            "package": payParams.package,	// prepay_id=wx21201855730335ac86f8c43d1889123400
            "signType": payParams.signType, //微信签名方式; RSA
            "paySign": payParams.paySign //微信签名
        }, function(res) {
            if (res.err_msg == "get_brand_wcpay_request:ok") {
                // 使用以上方式判断前端返回,微信团队郑重提示：
                //res.err_msg将在用户支付成功后返回ok，但并不保证它绝对可靠，商户需进一步调用后端查单确认支付结果。
                alert("支付成功");
                // 支付成功处理逻辑，例如跳转到成功页面
                window.location.href = "/payment-success";
            } else if (res.err_msg == "get_brand_wcpay_request:cancel") {
                alert("支付取消");
                // 用户取消支付处理逻辑
            } else {
                alert("支付失败");
                // 支付失败处理逻辑
                window.location.href = "/payment-failed";
            }
        });
    }

    // 检查是否在微信浏览器中
    if (typeof WeixinJSBridge === "undefined") {
        if (document.addEventListener) {
            document.addEventListener('WeixinJSBridgeReady', onBridgeReady, false);
        } else if (document.attachEvent) {
            document.attachEvent('WeixinJSBridgeReady', onBridgeReady);
            document.attachEvent('onWeixinJSBridgeReady', onBridgeReady);
        }
    } else {
        onBridgeReady();
    }
}

/**
 * 发起支付请求
 * @param {Object} orderInfo - 订单信息
 */
function requestPayment(orderInfo) {
    // 向后端发送支付请求
    fetch('/api/wechat/pay/jsapi', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            openid: orderInfo.openid,
            out_trade_no: orderInfo.out_trade_no,
            amount: orderInfo.amount,
            description: orderInfo.description,
            time_expire: orderInfo.time_expire
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.code === 0) {
            // 调用微信支付
            callWeChatPay(data.data);
        } else {
            alert('支付发起失败: ' + data.message);
        }
    })
    .catch(error => {
        console.error('Error:', error);
        alert('支付请求异常');
    });
}

// 使用示例
/*
const orderInfo = {
    openid: "oUpF8uMuAJO_M2pxb1Q9zNjWeS6o",
    out_trade_no: "20150806125346",
    amount: 100,  // 单位为分
    description: "商品描述",
    time_expire: "2025-01-01T12:00:00+08:00"
};

requestPayment(orderInfo);
*/
```

#### 2.4 使用步骤

##### 2.4.1 后端集成

1. 创建WeChatPayConfig实例并配置相关参数
2. 实例化WeChatJsApiPaymentService
3. 创建WeChatPayController处理HTTP请求

##### 2.4.2 前端集成

1. 引入wechat-jsapi-payment.js
2. 调用requestPayment函数发起支付

#### 2.5 注意事项

1. **签名算法**：微信支付V3版本使用SHA256 with RSA算法进行签名
2. **证书管理**：需要正确配置商户私钥和微信支付平台证书
3. **回调验证**：必须验证微信支付回调通知的签名，确保安全性
4. **HTTPS要求**：支付接口必须在HTTPS环境下使用
5. **域名配置**：需要在微信商户平台配置JSAPI支付授权目录

#### 2.6 安全建议

1. 所有支付相关接口都应进行身份验证
2. 验证支付金额与订单金额是否一致
3. 防止重复通知处理
4. 日志记录所有支付操作
5. 定期更新商户证书

#### 2.7 错误处理

常见的错误及处理方式：

1. 签名验证失败：检查证书和签名算法是否正确
2. prepay_id过期：重新调用下单接口获取
3. 支付取消：引导用户重新支付
4. 网络异常：提示用户检查网络并重试

#### 2.8 参考文档

- [微信支付官方文档 - JSAPI支付](https://pay.weixin.qq.com/doc/v3/merchant/4012791870)

## 二、第三方工具 WxJava

### 1. 简介

[binarywang/WxJava](https://github.com/binarywang/WxJava) 是一个开源、非官方、功能全面的微信 Java 开发工具包。它封装了微信开放平台、公众号、小程序、企业微信、视频号、微信支付等各个模块的 API 接口，大大简化了微信相关功能的开发工作。

### 2. 主要模块

- 微信小程序：`weixin-java-miniapp`
- 微信支付：`weixin-java-pay`
- 微信开放平台：`weixin-java-open`
- 微信公众号：`weixin-java-mp`
- 企业微信：`weixin-java-cp`
- 微信视频号/微信小店：`weixin-java-channel`

### 3. 优势特点

1. **全面支持**：支持微信所有模块的开发，包括公众号、小程序、支付、企业微信等
2. **易于集成**：提供 Spring Boot Starter，可快速集成到 Spring Boot 项目中
3. **自动更新**：及时跟进微信官方 API 更新，保持与最新版本同步
4. **文档完善**：提供详细的使用文档和示例代码
5. **社区活跃**：拥有大量使用者和贡献者，问题解决迅速
6. **稳定可靠**：经过多年发展和众多项目验证，稳定性高

### 4. 集成方式

#### 4.1 Maven 依赖

在项目 pom.xml 中添加相关依赖：

```
<!-- 微信支付模块 -->
<dependency>
    <groupId>com.github.binarywang</groupId>
    <artifactId>weixin-java-pay</artifactId>
    <version>4.7.0</version>
</dependency>

<!-- 微信公众号模块 -->
<dependency>
    <groupId>com.github.binarywang</groupId>
    <artifactId>weixin-java-mp</artifactId>
    <version>4.7.0</version>
</dependency>

<!-- 微信小程序模块 -->
<dependency>
    <groupId>com.github.binarywang</groupId>
    <artifactId>weixin-java-miniapp</artifactId>
    <version>4.7.0</version>
</dependency>
```

#### 4.2 Spring Boot 集成

使用 Spring Boot Starter 可以更方便地集成：

```
<dependency>
    <groupId>com.github.binarywang</groupId>
    <artifactId>wx-java-pay-spring-boot-starter</artifactId>
    <version>4.7.0</version>
</dependency>
```

### 5. 微信支付集成示例

使用 WxJava 可以大大简化微信支付的集成过程：

#### 5.1 配置文件

在 application.yml 中配置微信支付参数：

```
wx:
  pay:
    appId: your-app-id #微信公众号ID或者小程序等的appid (V3商户模式需要)
    mchId: your-mch-id #微信支付商户号 (V3商户模式需要)
    mchKey: your-mch-key #微信支付商户密钥
    subAppId: #服务商模式下的子商户公众账号ID
    subMchId: #服务商模式下的子商户号
    keyPath: classpath:cert/apiclient_cert.p12     # p12证书的位置，可以指定绝对路径，也可以指定类路径（以classpath:开头）
    apiV3Key: # apiV3 秘钥值 (V3商户模式需要)
    certSerialNo: # apiV3 证书序列号值 (V3商户模式需要)
    privateCertPath: # apiclient_cert.pem证书文件的绝对路径或者以classpath:开头的类路径. (V3商户模式需要)
    privateKeyPath: # apiclient_key.pem证书文件的绝对路径或者以classpath:开头的类路径. (V3商户模式需要)
    publicKeyPath: # 微信支付公钥，pub_key.pem证书文件的绝对路径或者以classpath:开头的类路径. (V3商户模式需要)
    publicKeyId: # 微信支付公钥ID (V3商户模式需要)
    notifyUrl: https://your-domain.com/pay/notify
```

#### 5.2 支付服务类

```
import com.github.binarywang.wxpay.bean.order.WxPayAppOrderResult;
import com.github.binarywang.wxpay.bean.order.WxPayMpOrderResult;
import com.github.binarywang.wxpay.bean.order.WxPayNativeOrderResult;
import com.github.binarywang.wxpay.bean.request.WxPayUnifiedOrderRequest;
import com.github.binarywang.wxpay.bean.result.WxPayOrderQueryResult;
import com.github.binarywang.wxpay.exception.WxPayException;
import com.github.binarywang.wxpay.service.WxPayService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class WxPayServiceImpl {
    
    @Autowired
    private WxPayService wxPayService;
    
    /**
     * JSAPI支付下单
     */
    public WxPayMpOrderResult createJsapiOrder(String openid, String outTradeNo, 
                                              int amount, String description) throws WxPayException {
        WxPayUnifiedOrderRequest request = WxPayUnifiedOrderRequest.newBuilder()
                .openid(openid)
                .outTradeNo(outTradeNo)
                .totalFee(amount)
                .body(description)
                .tradeType("JSAPI")
                .build();
        
        return wxPayService.createOrder(request);
    }
    
    /**
     * Native支付下单（二维码支付）
     */
    public WxPayNativeOrderResult createNativeOrder(String outTradeNo, 
                                                   int amount, String description) throws WxPayException {
        WxPayUnifiedOrderRequest request = WxPayUnifiedOrderRequest.newBuilder()
                .outTradeNo(outTradeNo)
                .totalFee(amount)
                .body(description)
                .tradeType("NATIVE")
                .build();
        
        return wxPayService.createOrder(request);
    }
    
    /**
     * 查询订单
     */
    public WxPayOrderQueryResult queryOrder(String outTradeNo) throws WxPayException {
        return wxPayService.queryOrder(null, outTradeNo);
    }
}
```



### 6. 使用建议

1. **新项目推荐**：对于新项目，强烈推荐使用 WxJava，可以显著提高开发效率
2. **老项目迁移**：老项目可以根据实际情况逐步迁移到 WxJava
3. **学习参考**：即使不直接使用，也可以参考其设计思路和实现方式
4. **问题排查**：遇到微信支付相关问题时，可以参考其源码进行排查

### 7. 相关资源

- [GitHub 项目地址](https://github.com/binarywang/WxJava)
- [开发文档 Wiki](https://github.com/binarywang/WxJava/wiki)
- [示例项目](https://github.com/binarywang/weixin-java-pay-demo)



## 三、当前现有代码的实现逻辑

### 1. 订单支付流程

#### 1.1 创建订单
调用服务方法创建订单:
```
com.mingyang.service.impl.HomeOrderServiceImpl#contractorOrder
```

#### 1.2 调用支付接口
调用支付接口并返回支付二维码(codeUrl):
```
com.mingyang.controller.PayController#unifiedOrder
com.mingyang.service.impl.PayServiceImpl#wxUnifiedOrder
```

#### 1.3 支付回调处理
支付成功后的回调处理:
```
com.mingyang.service.impl.HomeOrderServiceImpl#buildOrderPayCallback
```

### 2. 微信支付配置信息

#### 2.1 微信支付基本配置
配置类：`SysOrgConfigApi`；配置表：`sys_org_config_api`

| 配置项 | 配置名称 | 说明 |
|--------|---------|------|
| wxPayAppId | 微信支付应用ID | 微信支付分配的应用ID |
| wxPayMchId | 微信支付商户ID | 微信支付分配的商户ID |
| wxPayApiV2Key | 微信支付API v2密钥 | API v2版本的密钥 |
| wxPayKeyContent | 商户私钥内容 | 商户API证书私钥内容 |
| wxPayApiNotifyUrl | 支付结果通知URL | 接收微信支付异步通知地址 |
| wxPayTradeType | 交易类型 | 如: NATIVE、JSAPI等 |

> 注：JSAPI支付需要额外配置公众号信息和用户openId

#### 2.2 微信公众号配置
用于网页授权、获取用户信息等场景：

| 配置项 | 配置名称 | 说明 |
|--------|---------|------|
| wxAppid | 微信公众号AppId | 公众号唯一标识 |
| wxSecret | 微信公众号密钥 | 公众号开发者密码 |

#### 2.3 微信小程序配置
如果需要支持小程序支付：

| 配置项 | 配置名称 | 说明 |
|--------|---------|------|
| wxAppletAppid | 微信小程序AppId | 小程序唯一标识 |
| wxAppletSecret | 微信小程序密钥 | 小程序开发者密码 |

### 3. 配置获取机制

初始化支付配置信息并返回机构配置的方法:
```
com.mingyang.service.impl.PayServiceImpl#initWxPayServiceByOrgId
```

配置获取流程：
1. **优先获取机构个性化配置**
   - 从 `com.mingyang.common.org.OrgConfigService#getOrgApiConfig` 获取机构配置
2. **降级到全局配置**
   - 如果机构个性化配置不完整或不存在，则通过 `com.mingyang.common.feign.service.SysService#queryOrgConfigVoById` -> `com.mingyang.controller.SysOrgConfigApiController#getOrDefault` 获取全局配置

### 4. 配置管理平台

进入 [运营管理平台](http://192.168.100.9/web) (用户名: admin、密码: 111111)

#### 4.1 全局配置
路径：系统设置 -> 信息配置 -> 微信wechat

![全局配置界面](C:\Users\osmondy\AppData\Roaming\Typora\typora-user-images\image-20250911175340248.png)

#### 4.2 项目级配置
路径：项目管理 -> 项目配置 -> "项目配置" -> 微信wechat

![项目配置界面](C:\Users\osmondy\AppData\Roaming\Typora\typora-user-images\image-20250911180153855.png)

#### 4.3. 配置保存接口

配置保存的入口方法:
```
com.mingyang.controller.SysOrgConfigApiController#save
```

