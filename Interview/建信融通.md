**junit执行顺序**

​	@BeforeClass > @Before > @Test > @After > @AfterClass

> [ Junit单元测试 | 注解和执行顺序](https://www.jianshu.com/p/27107de9ab77)

**1万个人抢100个红包怎么保证两个人不会抢同一个**

**简述jvm垃圾回收机制CMS**

CMS: Concurrent Mark Sweep，并发标记清除
基于标记-清除算法（会产生内存碎片）
适用范围：仅针对于老年代

工作流程：

* 初始标记：用户线程STW，老年代内存不足，进行初始标记，即标记GCRoot直接关联的对象。这个阶段的速度算是很快的（只标记一层）
* 并发标记：与用户线程并发运行，根据标记为存活的对象向下追溯遍历，找出所有存活的对象；通过写屏障将老年代中引用变化的对象标记为 Dirty Card 脏卡（提高重新标记的效率，不需要扫描整个老年代 ）
* 重新标记：用户线程STW，由于在并发标记时，由于用户线程也在工作，对象的引用可能发生变化，需要重新标记修正，遍历GCRoot和Dirty Card
* 并发清理：与用户线程恢复并发运行，清理未使用的对象并回收

> [简述CMS垃圾回收器](https://blog.csdn.net/Swofford/article/details/125358604)



**限流的令牌桶算法和漏斗算法有什么差异，各自使用场景**

漏斗：流入速率不固定，流出速率均匀。如果流入速率>流出速率，满了请求会丢弃(使用MQ替代)。

令牌桶：固定速率产生令牌，获取不到令牌请求被丢弃。

使用场景：

* 漏斗算法：0点签到、秒杀

* 令牌桶：控制访问服务速度，防止把下游压垮

> [漏桶算法和令牌桶算法，区别到底在哪里？](https://xie.infoq.cn/article/4a0acdd12a0f6dd4a53e0472c)

**两阶段分布式事物幂等，防重入，空回滚解决方案**

**单链表寻找倒数第K个节点**

> [原题](https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)

```java
public ListNode getKthFromEnd(ListNode head, int k) {
    ListNode fast = head, slow = head;

    while(fast != null && k > 0) {
        fast = fast.next;
        k--;
    }

    while(fast != null) {
        fast = fast.next;
        slow = slow.next;
    }

    return slow;
}
```

**在存储Ip数据的100G文件里找出前100个出现次数最多的lp**

**解释深度分页，以及解决方案**

1. 使用主键索引：select * from t where **id > maxId** limit 20;
2. 使用子查询主键索引：select * from t where id > (select id from t limit 100000,1) limit 20;