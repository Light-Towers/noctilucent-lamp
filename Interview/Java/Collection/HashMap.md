## 讲一讲HashMap的get/put过程

### get过程

1. 如果哈希表为空，或key对应的桶为空，返回null
2. 如果桶中的第一个节点就和指定参数hash和key匹配上了，返回这个节点。
3. 如果桶中的第一个节点没有匹配上，而且有后续节点
    1. 如果当前的桶采用红黑树，则调用红黑树的get方法去获取节点
    2. 如果当前的桶不采用红黑树，即桶中节点结构为链式结构，遍历链表，直到key匹配
4. 找到节点返回，否则返回null。

### put过程

1. 判断键值对数组table是否为空或为null，否则执行resize()进行扩容； 

2. 根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③； 

3. 判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals； 

4. 判断table[i] 是否为treeNode，如果是红黑树，则直接在树中插入键值对，否则转向⑤；

5. 遍历table[i];
   1. 若发现key已经存在直接覆盖value
   2. 在链表尾部插入Node节点，判断链表长度是否大于8，大于8的话把链表转换为红黑树

6. 最后判断实际存在的键值对数量size是否超过最大容量threshold，如果超过，进行扩容。

## 为什么hashmap的在链表元素数量超过8时候改为红黑树

### 知道jdk1.8中hashmap改了什么吗。

1. 由数组+链表的结构改为数组+链表+红⿊树。
2. 优化了⾼位运算的hash算法：h^(h>>>16)
3. 扩容后，元素要么是在原位置，要么是在原位置再移动2次幂的位置，且链表顺序不变。
4. **注意**： 最后⼀条是重点，因为最后⼀条的变动，hashmap在1.8中，不会在出现死循环问题。

### 说一下为什么会出现线程的不安全性

### 为什么在解决hash冲突时候，不直接用红黑树，而是先用链表，再用红黑树

因为红⿊树需要进⾏左旋，右旋，变⾊这些操作来保持平衡，⽽单链表不需要。
当元素⼩于8个当时候，此时做查询操作，链表结构已经能保证查询性能。
当元素⼤于8个的时候，此时需要红⿊树来加快查 询速度，但是新增节点的效率变慢了。
因此，如果⼀开始就⽤红⿊树结构，元素太少，新增效率⼜⽐较慢，⽆疑这是浪费性能的。

### 当链表转为红黑树，什么时候退化为链表

为6的时候退转为链表。中间有个差值7可以防⽌链表和树之间频繁的转换。
假设⼀下，如果设计成链表个数超过8则链表转 换成树结构，链表个数⼩于8则树结构转换成链表，
如果⼀个HashMap不停的插⼊、删除元素，链表个数在8左右徘徊，就会 频繁的发⽣树转链表、链表转树，效率会很低。

## HashMap的并发问题

### HashMap在并发环境下会有什么问题

1. 多线程扩容，引起的死循环问题
2. 多线程put的时候可能导致元素丢失
3. put⾮null元素后get出来的却是null

### 一般是如何解决的

1. 在之前使用hashtable。 在每一个函数前面都加上了synchronized 但是 效率太低 我们现在不常用了。
2. 使用 ConcurrentHashmap函数，对于这个函数而言 我们可以每几个元素共用一把锁。用于提高效率。



## Refrence

[1]: https://zhuanlan.zhihu.com/p/127147909	"HashMap原理详解，看不懂算我输（附面试题）"