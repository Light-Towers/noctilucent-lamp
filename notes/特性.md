# 特性

1. 消息系统：消息队列具备系统解耦、冗余存储、流量削峰、缓冲、异步通信、扩展性、可恢复性等功能。此外，Kafka 还提供了消息顺序性保障及回溯消费的功能。
2. 存储系统：把消息数据持久化到磁盘。(默认7天，修改保留策略为“永久”或启用主题的日志压缩)。
3. 流式处理平台：提供一个完整的流式处理类库，比如窗口、连接、变换和聚合等各类操作。

# 概念

![img](%E5%88%9D%E8%AF%86Kafka.resources/Kafka%20%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E8%AE%BE%E8%AE%A1.jpg)

1. Producer：消息生产者
2. Consumer：消息消费者
3. Consumer Group：消费者分组，每个Consumer必须属于一个group
4. Broker：Kafka 服务代理节点，负责消息存储和转发
5. Topic：主题，按 topic 对消息分类
6. Partition：topic 的分区，一个topic可以包含多个分区，不同分区消息不同；在存储层面可看作一个可追加的日志（ Log ）文件
7. Offset：消息在被追加日志文件中会被配一个特定偏移量，代表消息在分区中的唯一标识；offset 不跨越分区
8. Replica：副本，增加副本数量可以提升容灾能力（同一时刻，副本之间数据并非完全一样）
9. Zookeeper：保存着集群broker、topic、partition等元(meta)数据；另外，还负责broker故障发现，partition leader 选举，负载均衡等功能
10. AR：Assigned Replicas，分区中的所有副本。AR=ISR+OSR
11. ISR：In-Sync Replicas，与 leader 副本保持 '一定程度' 同步的副本（包括 leader 副本）
12. OSR：Out-of-Sync Replicas，与 leader 副本同步 '滞后过多' 的副本（不包扩 leader 副本）

> 生产者和消费者只与 leader 副本进行交互，而 follow 副本只负责消息的同步。leader 副本负责维护和跟踪 ISR 集合中所有 follower 副本的滞后状态，当 follower 副本落后或失效时，leader 副本会把它从 ISR 集合中剔除; 如 OSR 集合中有 follower 副本 “追上” leader 副本，那么 leader 副本 它从 OSR 集合转移至 ISR 集合

![img](%E5%88%9D%E8%AF%86Kafka.resources/CECD0ACD-E536-478D-AA8D-33B3F7E503FF.png)
\13. HW：High Watermark（高水位），一个特定的 offset，消费者只能拉取到这个 offset 之前的消息(针对某一个分区)
\14. LEO：Log End Offset，下一条待写入消息 offset

# 快速开始

- 下载

```
wget https://dlcdn.apache.org/kafka/2.8.0/kafka_2.13-3.1.0.tgz
tar -xzf kafka_2.13-3.1.0.tgz
```

- 修改配置文件server.properties

```
# 实例唯一标识
broker.id=0
# 服务监听的端口号
listeners=PLAINTEXT://172.27.0.229:9092
advertised.listeners=PLAINTEXT://172.27.0.229:9092
# 系统副本因子
offsets.topic.replication.factor=3
transaction.state.log.replication.factor=3
transaction.state.log.min.isr=3
# 数据目录
log.dirs=/home/quant_group/data/kafka/kafka_datas
# zk地址
zookeeper.connect=172.27.0.229:2181,172.27.0.243:2181,172.27.0.193:2181
```

- Start service

```
# 启动zookeeper
bin/zookeeper-server-start.sh -daemon config/zookeeper.properties
# 启动Kafka
bin/kafka-server-start.sh -daemon config/server.properties
```

# 生产者

## 生产者原理

![img](%E5%88%9D%E8%AF%86Kafka.resources/0C13ADFA-3D3F-4F3A-B119-23EE5DB0D5BE.png)

- 生产者客户端由`主线程` + `Sender线程`构成。主线程中由`KafkaProducer`生产消息，然后经过拦截器、序列化器分区器作用后缓存到`RecordAccumulator（消息累加器）`；Sender线程负责从 RecordAccumulator 中获取消息并发送到 Kafka 中。
- RecordAccumulator：缓存消息以便 Sender线程 批量发送，进而减少网络传输次数提升整体吞吐量。默认缓存大小`buffer.memory=32M`。RecordAccumulator的内部为每个分区都维护一个双端队列：`Deque<ProducerBatch>`，消息追加到队列尾部，Sender从队列头部读取消息。`ProducerBatch`指一个消息批次，包含多个`ProducerRecord`。
- BufferPool：RecordAccumulator内部会维护一个`BufferPool`，减少频繁的创建和释放`ByteBuffer`。只针对特定大小ByteBuffer进行管理，默认`batch.size=16KB`
- Sender 线程获取消息后，会进一步将原本`<分区, Deque<ProducerBatch>>`的保存形式转变为`<Node, List<ProducerBatch>>`，Node代表Kafka的broker节点。之后还会进一步封装成`<Node, Request>`形式，Request代表Kafka的请求协议。
- 请求从 Sender 线程发往 Kafka 之前还会保存在`InFlightRequests`中，InFlightRequests 中保存的对象形式为`Map<NodeId, Deque<Request>>`，作用是缓存已经发布去但还没有收到响应的请求，默认缓存5个未响应的请求，`max.in.flight.requests.per.connect=5`。

## 发送模式

- 发后即忘（fire-and-forget）
- 异步（async）
- 同步（sync）

## 生产客户端

步骤：
\1. 配置生产者客户端参数及创建响应生产者实例
\2. 构建待发送的消息
\3. 发送消息
\4. 关闭生产者实例

```
public class Producer {
    public static void main(String[] args) {
        // 1. 配置生产者客户端参数及创建响应生产者实例
        Properties properties = new Properties();
        // 连接集群 bootstrap.servers
        properties.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, "127.0.0.1:9092");
        // 指定对应的key和value的序列化类型 key.serializer
        properties.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());
        properties.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());
        // 创建kafka生产者对象
        KafkaProducer<String, String> producer = new KafkaProducer<>(properties);
        // 2. 构建待发送的消息
        ProducerRecord<String, String> record = new ProducerRecord<>("first", "Hello, kafka");
        // 3. 发送数据
        try {
            // a. 发后即忘。 send() 默认异步
            producer.send(record);
            // b. 异步回调
            producer.send(record, new Callback() {
                // RecordMetadata 与 Exception 存在互斥
                @Override
                public void onCompletion(RecordMetadata metadata, Exception e) {
                    if (e == null){
                        System.out.println("topic："+metadata.topic() + " partition："+ metadata.partition());
                    } else {
                        // 记录错误日志 或 处理让消息重发
                        e.printStackTrace();
                    }
                }
            });
            // c. 同步
            producer.send(record).get();
        } catch (InterruptedException | ExecutionException e) {
            // 记录错误日志 或 处理让消息重发
            e.printStackTrace();
        }
        // 4. 关闭资源
        producer.close();
    }
}
```

## Ack确认机制

0：生产者发送消息后，不需要等broker响应。吞吐量最大，会丢消息。
1：acks的默认值；生产者会收到leader副本写入成功的响应。如leader副本返回成功响应给生产者的时候，被follow副本拉取前挂了，那么消息还会丢。
-1：或acks=all；生产者发送消息后，需要等ISR中所有副本都成功响应。消息可靠性最高，性能最差。

# 消费者

## 消费者与消费组

消息队列的两种模式：

- 点对点：一对一，基于队列，消息生产者发送消息到队列，消息消费者从队列中接收消息。(消费后消息会被清除。Kafka待验证)

- 发布/订阅：一对多，同时有多个消息消费者（订阅）消费该消息。消息生产者将消息发布到topic，而消息消费者从topic中订阅消息。topic使得消息的订阅者和发布者互相保持独立，不需要进行接触即可保证消息的传递。

  Kafka的实现：

  - 如果所有的消费者都隶属于同一个消费组，那么所有的消息都会被均衡地投递给每一个消费者，即每条消息只会被一个消费者处理，这就相当千点对点模式的应用。
  - 如果所有的消费者都隶属于不同的消费组，那么所有的消息都会被广播给所有的消费者，即每条消息会被所有的消费者处理，这就相当于发布／订阅模式的应用。

消费组是一个逻辑上的概念， 它将旗下的消费者归为一类，每一个消费者只隶属于一个消费组。每一个消费组都会有一个固定的名称，可通过消费者客户端参数group.id来配置，默认值为空字符串。消费者并非逻辑上的概念，它是实际的应用实例，它可以是一个线程，也可以是一个进程。同一个消费组内的消费者既可以部署在同一台机器上， 也可以部署在不同的机器上。

## 消费客户端

步骤：
\1. 配置消费者客户端参数及创建相应的消费者实例
\2. 订阅主题
\3. 拉取消息并消费
\4. 提交消费位移
\5. 关闭消费者实例

## 分区分配策略

分区分配策略（partition.assignment.strategy）；默认分配器是 [RangeAssignor, CooperativeStickyAssignor]，默认情况下将使用 RangeAssignor，但允许升级到 CooperativeStickyAssignor，只需一个滚动反弹即可从列表中删除 RangeAssignor。

- RangeAssignor：按主题分配分区。
- RoundRobinAssignorP：以循环方式将分区分配给消费者。
- StickyAssignor：保证分配是最大平衡的，同时保留尽可能多的现有分区分配。
- CooperativeStickyAssignor：遵循相同的 StickyAssignor 逻辑，但允许合作再平衡。

# Broker

# 日志

Kafka 日志关系
![img](%E5%88%9D%E8%AF%86Kafka.resources/C701E874-AD64-4C1E-A7EE-392A36616AB5.png)

# topic

topic命名规则
不推荐以双下划线__开头，因为以双下划线开头的topic一般看作是kafka的内部topic
不推荐句点号. 或者下划线_，kafka会根据topic名称来命名metrics的名称，会将句点号. 改成下划线_





![Saas架构图设计-架构图.drawio](/Users/yangjinhua/Research/noctilucent-lamp/notes/特性.assets/Saas架构图设计-架构图.drawio.png)![]()